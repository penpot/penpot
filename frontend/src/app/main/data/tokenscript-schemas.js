// Auto-generated by @tokens-studio/tokenscript-schemas
// Version: @tokens-studio/tokenscript-schemas@v0.1.2
// GitHub: https://github.com/tokens-studio/tokenscript-schemas
// Command: npx @tokens-studio/tokenscript-schemas bundle preset:css --output ./tokenscript-schemas.js
// Generated: 2026-01-07T09:21:11.478Z

import { Config } from "@tokens-studio/tokenscript-interpreter";

export const SCHEMAS = [
  {
    uri: "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/hex-color/0/",
    schema: {
      "name": "Hex",
      "type": "color",
      "description": "A color in hex format, e.g. #ff0000",
      "schema": {
        "type": "object",
        "properties": {
          "value": {
            "type": "string"
          }
        }
      },
      "initializers": [
        {
          "title": "Hex Color Initializer",
          "keyword": "hex",
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "variable c: Color.Hex;\nc.value = {input};\nreturn c;"
          }
        }
      ],
      "conversions": []
    }
  },
  {
    uri: "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/rgb-color/0/",
    schema: {
      "name": "Rgb",
      "type": "color",
      "description": "RGB color",
      "schema": {
        "type": "object",
        "properties": {
          "r": {
            "type": "number"
          },
          "g": {
            "type": "number"
          },
          "b": {
            "type": "number"
          }
        },
        "required": [
          "r",
          "g",
          "b"
        ],
        "order": [
          "r",
          "g",
          "b"
        ],
        "additionalProperties": false
      },
      "initializers": [
        {
          "title": "function",
          "keyword": "rgb",
          "description": "Creates an RGB color",
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// RGB Color Initializer\n// Creates an RGB color from r, g, b values (0-255 range)\n//\n// Usage: rgb(255, 128, 64) → Color.Rgb { r: 255, g: 128, b: 64 }\n//        rgb(255, 128, 64, 0.5) → Color.Rgb { r: 255, g: 128, b: 64, alpha: 0.5 }\n//\n// Input: List of 3 or 4 numbers [r, g, b] or [r, g, b, alpha]\n// Output: Color.Rgb\n\nvariable color_parts: List = {input}; \n\nvariable output: Color.Rgb;\noutput.r = color_parts.get(0);\noutput.g = color_parts.get(1);\noutput.b = color_parts.get(2);\n\n// Set alpha if provided as 4th parameter\nif (color_parts.length() > 3) [\n  output.alpha = color_parts.get(3);\n];\n\nreturn output;"
          }
        },
        {
          "title": "function",
          "keyword": "rgba",
          "description": "Creates an RGB color with alpha",
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// RGBA Color Initializer\n// Creates an RGB color with alpha from r, g, b, a values\n//\n// Usage: rgba(255, 128, 64, 0.5) → Color.Rgb { r: 255, g: 128, b: 64, alpha: 0.5 }\n//\n// Input: List of 4 numbers [r, g, b, alpha]\n// Output: Color.Rgb with alpha\n\nvariable color_parts: List = {input}; \n\nvariable output: Color.Rgb;\noutput.r = color_parts.get(0);\noutput.g = color_parts.get(1);\noutput.b = color_parts.get(2);\noutput.alpha = color_parts.get(3);\n\nreturn output;"
          }
        }
      ],
      "conversions": [
        {
          "source": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/hex-color/0/",
          "target": "$self",
          "description": "Converts HEX to RGB",
          "lossless": true,
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// Hex to RGB Conversion\n// Converts hexadecimal color string to RGB (0-255 range)\n//\n// Supports both shorthand (#RGB) and standard (#RRGGBB) formats:\n//   #f00     → RGB(255, 0, 0)\n//   #ff0000  → RGB(255, 0, 0)\n//\n// Algorithm:\n// 1. Remove '#' prefix and split into characters\n// 2. For shorthand: duplicate each digit (f → ff)\n// 3. Parse hex pairs to decimal values\n//\n// Input: Color.Hex (e.g., #ff5733)\n// Output: Color.Rgb with r, g, b in 0-255 range\n\n// Split hex string on '#' and get the color value\nvariable color_parts: List = {input}.to_string().split('#'); \nvariable color: List = color_parts.get(1).split(); \nvariable length: Number = color.length(); \n\n// Initialize RGB values\nvariable rgb: List = 0, 0, 0; \n\n// Handle shorthand (#RGB) vs standard (#RRGGBB) format\nif(length == 3) [ \n  // Shorthand: duplicate each digit\n  rgb.update(0, parse_int(color.get(0).concat(color.get(0)), 16)); \n  rgb.update(1, parse_int(color.get(1).concat(color.get(1)), 16)); \n  rgb.update(2, parse_int(color.get(2).concat(color.get(2)), 16)); \n] else [ \n  // Standard: pair adjacent digits\n  rgb.update(0, parse_int(color.get(0).concat(color.get(1)), 16)); \n  rgb.update(1, parse_int(color.get(2).concat(color.get(3)), 16)); \n  rgb.update(2, parse_int(color.get(4).concat(color.get(5)), 16)); \n]; \n\n// Create output color\nvariable output: Color.Rgb; \noutput.r = rgb.get(0); \noutput.g = rgb.get(1); \noutput.b = rgb.get(2); \n\nreturn output;"
          }
        },
        {
          "source": "$self",
          "target": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/hex-color/0/",
          "description": "Converts RGB to HEX",
          "lossless": true,
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// RGB to Hex Conversion\n// Converts RGB (0-255) color to hexadecimal string format\n//\n// Examples:\n//   RGB(255, 0, 0)   → #ff0000\n//   RGB(0, 255, 128) → #00ff80\n//\n// Algorithm:\n// 1. Round each channel to nearest integer\n// 2. Convert to base-16 string\n// 3. Pad single digits with leading zero\n// 4. Concatenate with '#' prefix\n//\n// Input: Color.Rgb with r, g, b in 0-255 range\n// Output: String (hex format #rrggbb)\n\nvariable rgba: List = {input}.r, {input}.g, {input}.b;\nvariable hex: String = \"#\";\nvariable i: Number = 0;\nvariable value: Number = 0;\n\n// Convert each RGB channel to hex\nwhile( i < min(rgba.length(), 3)) [\n  value = round(rgba.get(i));\n  if(value < 16) [\n    hex = hex.concat(\"0\").concat(value.to_string(16));\n  ] else [\n    hex = hex.concat(value.to_string(16));\n  ];\n  i = i + 1;\n];\n\nif (rgba.length() == 4) [\n  value = rgba.get(3) * 255; // Convert alpha to 0-255 range\n  if(value < 16) [\n    hex = hex.concat(\"0\").concat(value.to_string(16));\n  ] else [\n    hex = hex.concat(value.to_string(16));\n  ];\n];\n\nreturn hex;"
          }
        }
      ]
    }
  },
  {
    uri: "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/hsl-color/0/",
    schema: {
      "name": "HSL",
      "type": "color",
      "description": "HSL color space - Hue, Saturation, Lightness. Popular for color pickers and CSS.",
      "schema": {
        "type": "object",
        "properties": {
          "h": {
            "type": "number",
            "description": "Hue angle (0-360 degrees)"
          },
          "s": {
            "type": "number",
            "description": "Saturation (0-1)"
          },
          "l": {
            "type": "number",
            "description": "Lightness (0-1)"
          }
        },
        "required": [
          "h",
          "s",
          "l"
        ],
        "order": [
          "h",
          "s",
          "l"
        ],
        "additionalProperties": false
      },
      "initializers": [
        {
          "title": "HSL Color Initializer",
          "keyword": "hsl",
          "description": "Creates an HSL color from H, S, L values",
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// HSL Color Initializer\n// Creates an HSL color from H, S, L values\n// Input: List of [h, s, l] or [h, s, l, alpha] values\n\nvariable hsl_values: List = {input};\nvariable output: Color.HSL;\n\noutput.h = hsl_values.get(0);\noutput.s = hsl_values.get(1);\noutput.l = hsl_values.get(2);\n\n// Set alpha if provided as 4th parameter\nif (hsl_values.length() > 3) [\n  output.alpha = hsl_values.get(3);\n];\n\nreturn output;"
          }
        },
        {
          "title": "HSLA Color Initializer",
          "keyword": "hsla",
          "description": "Creates an HSL color with alpha from H, S, L, A values",
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// HSLA Color Initializer\n// Creates an HSL color with alpha from H, S, L, A values\n//\n// Usage: hsla(180, 0.5, 0.5, 0.8) → Color.HSL { h: 180, s: 0.5, l: 0.5, alpha: 0.8 }\n//\n// Input: List of 4 numbers [h, s, l, alpha]\n// Output: Color.HSL with alpha\n\nvariable hsl_values: List = {input};\nvariable output: Color.HSL;\n\noutput.h = hsl_values.get(0);\noutput.s = hsl_values.get(1);\noutput.l = hsl_values.get(2);\noutput.alpha = hsl_values.get(3);\n\nreturn output;"
          }
        }
      ],
      "conversions": [
        {
          "source": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/srgb-color/0/",
          "target": "$self",
          "description": "Converts sRGB to HSL",
          "lossless": true,
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// sRGB to HSL Conversion\n// Reference: https://github.com/color-js/color.js/blob/main/src/spaces/hsl.js\n//\n// Algorithm:\n// 1. Find max and min of R, G, B\n// 2. L = (max + min) / 2\n// 3. If max == min, S = 0 (achromatic)\n// 4. Else S = (max - min) / (1 - |2L - 1|)\n// 5. H depends on which channel is max\n//\n// Input: Color.SRGB with r, g, b in 0-1 range\n// Output: Color.HSL with h (0-360), s (0-1), l (0-1)\n\n// Get input sRGB values\nvariable r: Number = {input}.r;\nvariable g: Number = {input}.g;\nvariable b: Number = {input}.b;\n\n// Find max and min\nvariable max_val: Number = r;\nif (g > max_val) [\n    max_val = g;\n];\nif (b > max_val) [\n    max_val = b;\n];\n\nvariable min_val: Number = r;\nif (g < min_val) [\n    min_val = g;\n];\nif (b < min_val) [\n    min_val = b;\n];\n\n// Calculate lightness\nvariable l: Number = (max_val + min_val) / 2;\n\n// Calculate saturation and hue\nvariable s: Number = 0;\nvariable h: Number = 0;\nvariable delta: Number = max_val - min_val;\n\nif (delta > 0) [\n    // Not achromatic\n    \n    // Saturation formula\n    variable abs_2l_minus_1: Number = 2 * l - 1;\n    if (abs_2l_minus_1 < 0) [\n        abs_2l_minus_1 = 0 - abs_2l_minus_1;\n    ];\n    s = delta / (1 - abs_2l_minus_1);\n    \n    // Hue calculation depends on which channel is max\n    if (max_val == r) [\n        h = ((g - b) / delta);\n        if (g < b) [\n            h = h + 6;\n        ];\n    ] else [\n        if (max_val == g) [\n            h = (b - r) / delta + 2;\n        ] else [\n            h = (r - g) / delta + 4;\n        ];\n    ];\n    \n    // Convert to degrees\n    h = h * 60;\n];\n\n// Normalize hue to 0-360\nif (h < 0) [\n    h = h + 360;\n];\n\n// Create output\nvariable output: Color.HSL;\noutput.h = h;\noutput.s = s;\noutput.l = l;\n\nreturn output;"
          }
        }
      ]
    }
  },
  {
    uri: "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/srgb-color/0/",
    schema: {
      "name": "SRGB",
      "type": "color",
      "description": "sRGB color space with normalized 0-1 range. The standard color space for web and displays.",
      "schema": {
        "type": "object",
        "properties": {
          "r": {
            "type": "number",
            "description": "Red channel (0-1)"
          },
          "g": {
            "type": "number",
            "description": "Green channel (0-1)"
          },
          "b": {
            "type": "number",
            "description": "Blue channel (0-1)"
          }
        },
        "required": [
          "r",
          "g",
          "b"
        ],
        "order": [
          "r",
          "g",
          "b"
        ],
        "additionalProperties": false
      },
      "initializers": [
        {
          "title": "sRGB Color Initializer",
          "keyword": "srgb",
          "description": "Creates an sRGB color from normalized 0-1 values",
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// sRGB Color Initializer\n// Creates an sRGB color from normalized 0-1 values\n// Input: List of [r, g, b] or [r, g, b, alpha] values in 0-1 range\n\nvariable color_values: List = {input};\nvariable output: Color.SRGB;\n\noutput.r = color_values.get(0);\noutput.g = color_values.get(1);\noutput.b = color_values.get(2);\n\n// Set alpha if provided as 4th parameter\nif (color_values.length() > 3) [\n  output.alpha = color_values.get(3);\n];\n\nreturn output;"
          }
        }
      ],
      "conversions": [
        {
          "source": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/rgb-color/0/",
          "target": "$self",
          "description": "Converts RGB (0-255) to sRGB (0-1) by normalizing",
          "lossless": true,
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// RGB to sRGB Conversion\n// Converts RGB (0-255) to sRGB (0-1) by normalizing\n// Input: Color.Rgb with r, g, b in 0-255 range\n// Output: Color.SRGB with r, g, b in 0-1 range\n// Lossless: Yes (simple division)\n\nvariable r_normalized: Number = {input}.r / 255;\nvariable g_normalized: Number = {input}.g / 255;\nvariable b_normalized: Number = {input}.b / 255;\n\nvariable output: Color.SRGB;\noutput.r = r_normalized;\noutput.g = g_normalized;\noutput.b = b_normalized;\n\nreturn output;"
          }
        },
        {
          "source": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/hsl-color/0/",
          "target": "$self",
          "description": "Converts HSL to sRGB",
          "lossless": true,
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// HSL to sRGB Conversion\n// Reference: https://github.com/color-js/color.js/blob/main/src/spaces/hsl.js\n//\n// Algorithm:\n// 1. If saturation is 0, it's achromatic: R=G=B=L\n// 2. Otherwise use the HSL to RGB formula:\n//    - Calculate intermediate values based on L\n//    - Use hue to determine RGB components\n//\n// Input: Color.HSL with h (0-360), s (0-1), l (0-1)\n// Output: Color.SRGB with r, g, b in 0-1 range\n\n// Get input HSL values\nvariable h: Number = {input}.h;\nvariable s: Number = {input}.s;\nvariable l: Number = {input}.l;\n\n// Normalize hue to 0-1 range\nvariable hue: Number = h / 360;\n\n// Output values\nvariable r: Number = l;\nvariable g: Number = l;\nvariable b: Number = l;\n\n// Only calculate if there's saturation (not achromatic)\nif (s > 0) [\n    // Calculate intermediate value\n    variable q: Number = 0;\n    if (l < 0.5) [\n        q = l * (1 + s);\n    ] else [\n        q = l + s - l * s;\n    ];\n    \n    variable p: Number = 2 * l - q;\n    \n    // Helper function logic inlined for R (hue + 1/3)\n    variable tr: Number = hue + 0.333333333333333;\n    if (tr < 0) [ tr = tr + 1; ];\n    if (tr > 1) [ tr = tr - 1; ];\n    \n    if (tr < 0.166666666666667) [\n        r = p + (q - p) * 6 * tr;\n    ] else [\n        if (tr < 0.5) [\n            r = q;\n        ] else [\n            if (tr < 0.666666666666667) [\n                r = p + (q - p) * (0.666666666666667 - tr) * 6;\n            ] else [\n                r = p;\n            ];\n        ];\n    ];\n    \n    // Helper function logic inlined for G (hue)\n    variable tg: Number = hue;\n    if (tg < 0) [ tg = tg + 1; ];\n    if (tg > 1) [ tg = tg - 1; ];\n    \n    if (tg < 0.166666666666667) [\n        g = p + (q - p) * 6 * tg;\n    ] else [\n        if (tg < 0.5) [\n            g = q;\n        ] else [\n            if (tg < 0.666666666666667) [\n                g = p + (q - p) * (0.666666666666667 - tg) * 6;\n            ] else [\n                g = p;\n            ];\n        ];\n    ];\n    \n    // Helper function logic inlined for B (hue - 1/3)\n    variable tb: Number = hue - 0.333333333333333;\n    if (tb < 0) [ tb = tb + 1; ];\n    if (tb > 1) [ tb = tb - 1; ];\n    \n    if (tb < 0.166666666666667) [\n        b = p + (q - p) * 6 * tb;\n    ] else [\n        if (tb < 0.5) [\n            b = q;\n        ] else [\n            if (tb < 0.666666666666667) [\n                b = p + (q - p) * (0.666666666666667 - tb) * 6;\n            ] else [\n                b = p;\n            ];\n        ];\n    ];\n];\n\n// Create output\nvariable output: Color.SRGB;\noutput.r = r;\noutput.g = g;\noutput.b = b;\n\nreturn output;"
          }
        },
        {
          "source": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/srgb-linear-color/0/",
          "target": "$self",
          "description": "Converts Linear sRGB to sRGB by applying gamma correction",
          "lossless": true,
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// Linear sRGB to sRGB Conversion\n// Applies gamma correction (transfer function)\n// Reference: IEC 61966-2-1:1999 (sRGB specification)\n//\n// Algorithm:\n//   if linear ≤ 0.0031308: srgb = linear * 12.92\n//   else: srgb = 1.055 * linear^(1/2.4) - 0.055\n//\n// Input: Color.LinearSRGB with r, g, b in linear 0-1 range\n// Output: Color.SRGB with r, g, b in gamma-corrected 0-1 range\n\n// Gamma correction constants (IEC 61966-2-1)\nvariable threshold: Number = 0.0031308;\nvariable linear_scale: Number = 12.92;\nvariable gamma_offset: Number = 0.055;\nvariable gamma_scale: Number = 1.055;\nvariable gamma_exponent: Number = 0.416666666666667;\n\n// Get input linear values\nvariable linear_r: Number = {input}.r;\nvariable linear_g: Number = {input}.g;\nvariable linear_b: Number = {input}.b;\n\n// Convert red channel\nvariable srgb_r: Number = 0;\nif (linear_r <= threshold) [\n    srgb_r = linear_r * linear_scale;\n] else [\n    srgb_r = gamma_scale * pow(linear_r, gamma_exponent) - gamma_offset;\n];\n\n// Convert green channel\nvariable srgb_g: Number = 0;\nif (linear_g <= threshold) [\n    srgb_g = linear_g * linear_scale;\n] else [\n    srgb_g = gamma_scale * pow(linear_g, gamma_exponent) - gamma_offset;\n];\n\n// Convert blue channel\nvariable srgb_b: Number = 0;\nif (linear_b <= threshold) [\n    srgb_b = linear_b * linear_scale;\n] else [\n    srgb_b = gamma_scale * pow(linear_b, gamma_exponent) - gamma_offset;\n];\n\n// Create output\nvariable output: Color.SRGB;\noutput.r = srgb_r;\noutput.g = srgb_g;\noutput.b = srgb_b;\n\nreturn output;"
          }
        }
      ]
    }
  },
  {
    uri: "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/srgb-linear-color/0/",
    schema: {
      "name": "LinearSRGB",
      "type": "color",
      "description": "Linear sRGB color space (gamma-decoded). Used for matrix transformations to XYZ and other linear operations.",
      "schema": {
        "type": "object",
        "properties": {
          "r": {
            "type": "number",
            "description": "Linear red channel (0-1)"
          },
          "g": {
            "type": "number",
            "description": "Linear green channel (0-1)"
          },
          "b": {
            "type": "number",
            "description": "Linear blue channel (0-1)"
          }
        },
        "required": [
          "r",
          "g",
          "b"
        ],
        "order": [
          "r",
          "g",
          "b"
        ],
        "additionalProperties": false
      },
      "initializers": [
        {
          "title": "Linear sRGB Color Initializer",
          "keyword": "linearsrgb",
          "description": "Creates a linear sRGB color from linear 0-1 values",
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// Linear sRGB Color Initializer\n// Creates a linear sRGB color from linear 0-1 values\n// Input: List of [r, g, b] linear values\n\nvariable color_values: List = {input};\nvariable output: Color.LinearSRGB;\n\noutput.r = color_values.get(0);\noutput.g = color_values.get(1);\noutput.b = color_values.get(2);\n\nreturn output;"
          }
        }
      ],
      "conversions": [
        {
          "source": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/srgb-color/0/",
          "target": "$self",
          "description": "Converts sRGB to Linear sRGB by removing gamma correction (IEC 61966-2-1)",
          "lossless": true,
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// sRGB to Linear sRGB Conversion\n// Removes gamma correction (inverse transfer function)\n// Reference: IEC 61966-2-1:1999 (sRGB specification)\n//\n// Algorithm:\n//   if srgb ≤ 0.04045: linear = srgb / 12.92\n//   else: linear = ((srgb + 0.055) / 1.055) ^ 2.4\n//\n// Input: Color.SRGB with r, g, b in 0-1 range\n// Output: Color.LinearSRGB with r, g, b in linear 0-1 range\n\n// Gamma correction constants (IEC 61966-2-1)\nvariable threshold: Number = 0.04045;\nvariable linear_scale: Number = 12.92;\nvariable gamma_offset: Number = 0.055;\nvariable gamma_scale: Number = 1.055;\nvariable gamma_exponent: Number = 2.4;\n\n// Get input sRGB values\nvariable srgb_r: Number = {input}.r;\nvariable srgb_g: Number = {input}.g;\nvariable srgb_b: Number = {input}.b;\n\n// Convert red channel\nvariable linear_r: Number = 0;\nif (srgb_r <= threshold) [\n    linear_r = srgb_r / linear_scale;\n] else [\n    linear_r = pow((srgb_r + gamma_offset) / gamma_scale, gamma_exponent);\n];\n\n// Convert green channel\nvariable linear_g: Number = 0;\nif (srgb_g <= threshold) [\n    linear_g = srgb_g / linear_scale;\n] else [\n    linear_g = pow((srgb_g + gamma_offset) / gamma_scale, gamma_exponent);\n];\n\n// Convert blue channel\nvariable linear_b: Number = 0;\nif (srgb_b <= threshold) [\n    linear_b = srgb_b / linear_scale;\n] else [\n    linear_b = pow((srgb_b + gamma_offset) / gamma_scale, gamma_exponent);\n];\n\n// Create output\nvariable output: Color.LinearSRGB;\noutput.r = linear_r;\noutput.g = linear_g;\noutput.b = linear_b;\n\nreturn output;"
          }
        },
        {
          "source": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/xyz-d65-color/0/",
          "target": "$self",
          "description": "Converts XYZ-D65 to Linear sRGB using inverse transformation matrix",
          "lossless": true,
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// XYZ-D65 to Linear sRGB Conversion\n// Reference: ColorJS exact matrix values (extracted via unit vector conversion)\n//\n// Matrix (XYZ D65 to Linear sRGB):\n//   [ 3.2409699419045226, -1.537383177570094,  -0.4986107602930034 ]\n//   [-0.9692436362808796,  1.8759675015077202,  0.04155505740717559]\n//   [ 0.05563007969699366, -0.20397695888897652, 1.0569715142428786]\n//\n// Input: Color.XYZD65 with x, y, z tristimulus values\n// Output: Color.LinearSRGB with r, g, b in linear 0-1 range\n\n// Get input XYZ values\nvariable x: Number = {input}.x;\nvariable y: Number = {input}.y;\nvariable z: Number = {input}.z;\n\n// Apply inverse matrix transformation (ColorJS exact values)\n// Row 1: R\nvariable linear_r: Number = 3.2409699419045226 * x + -1.537383177570094 * y + -0.4986107602930034 * z;\n\n// Row 2: G\nvariable linear_g: Number = -0.9692436362808796 * x + 1.8759675015077202 * y + 0.04155505740717559 * z;\n\n// Row 3: B\nvariable linear_b: Number = 0.05563007969699366 * x + -0.20397695888897652 * y + 1.0569715142428786 * z;\n\n// Create output\nvariable output: Color.LinearSRGB;\noutput.r = linear_r;\noutput.g = linear_g;\noutput.b = linear_b;\n\nreturn output;"
          }
        }
      ]
    }
  },
  {
    uri: "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/xyz-d65-color/0/",
    schema: {
      "name": "XYZD65",
      "type": "color",
      "description": "CIE XYZ color space with D65 white point. The primary connection hub for color space conversions.",
      "schema": {
        "type": "object",
        "properties": {
          "x": {
            "type": "number",
            "description": "X tristimulus value"
          },
          "y": {
            "type": "number",
            "description": "Y tristimulus value (luminance)"
          },
          "z": {
            "type": "number",
            "description": "Z tristimulus value"
          }
        },
        "required": [
          "x",
          "y",
          "z"
        ],
        "order": [
          "x",
          "y",
          "z"
        ],
        "additionalProperties": false
      },
      "initializers": [
        {
          "title": "XYZ-D65 Color Initializer",
          "keyword": "xyzd65",
          "description": "Creates an XYZ-D65 color from tristimulus values",
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// XYZ-D65 Color Initializer\n// Creates an XYZ-D65 color from tristimulus values\n// Input: List of [x, y, z] tristimulus values\n\nvariable xyz_values: List = {input};\nvariable output: Color.XYZD65;\n\noutput.x = xyz_values.get(0);\noutput.y = xyz_values.get(1);\noutput.z = xyz_values.get(2);\n\nreturn output;"
          }
        }
      ],
      "conversions": [
        {
          "source": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/srgb-linear-color/0/",
          "target": "$self",
          "description": "Converts Linear sRGB to XYZ-D65 using the sRGB transformation matrix",
          "lossless": true,
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// Linear sRGB to XYZ-D65 Conversion\n// Uses the sRGB primaries transformation matrix\n// Reference: IEC 61966-2-1:1999 (sRGB specification)\n//\n// Matrix (Linear RGB → XYZ-D65):\n// [X]   [0.4123908  0.3575843  0.1804808] [R]\n// [Y] = [0.2126390  0.7151687  0.0721923] [G]\n// [Z]   [0.0193308  0.1191948  0.9505322] [B]\n//\n// Input: Color.LinearSRGB with r, g, b in linear 0-1 range\n// Output: Color.XYZD65 with x, y, z tristimulus values\n\n// Get input linear sRGB values\nvariable r: Number = {input}.r;\nvariable g: Number = {input}.g;\nvariable b: Number = {input}.b;\n\n// Matrix multiplication: M × [R, G, B]ᵀ\n// Row 1: X = 0.4123908 * R + 0.3575843 * G + 0.1804808 * B\nvariable x: Number = r * 0.41239079926595934 + g * 0.357584339383878 + b * 0.1804807884018343;\n\n// Row 2: Y = 0.2126390 * R + 0.7151687 * G + 0.0721923 * B\nvariable y: Number = r * 0.21263900587151027 + g * 0.715168678767756 + b * 0.07219231536073371;\n\n// Row 3: Z = 0.0193308 * R + 0.1191948 * G + 0.9505322 * B\nvariable z: Number = r * 0.01933081871559182 + g * 0.11919477979462598 + b * 0.9505321522496607;\n\n// Create output\nvariable output: Color.XYZD65;\noutput.x = x;\noutput.y = y;\noutput.z = z;\n\nreturn output;"
          }
        },
        {
          "source": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/p3-linear-color/0/",
          "target": "$self",
          "description": "Converts Linear P3 to XYZ-D65 using the P3 transformation matrix",
          "lossless": true,
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// Linear P3 to XYZ-D65 Conversion\n// Converts linear Display-P3 RGB to CIE XYZ (D65)\n// Reference: CSS Color Level 4 specification\n//\n// Uses the P3 to XYZ-D65 transformation matrix\n// Matrix values from ColorJS / CSS Color Level 4\n//\n// Input: Color.LinearP3 with linear r, g, b values\n// Output: Color.XYZD65 with x, y, z tristimulus values\n\n// Get linear P3 values\nvariable r: Number = {input}.r;\nvariable g: Number = {input}.g;\nvariable b: Number = {input}.b;\n\n// Linear P3 to XYZ-D65 matrix\n// Row 1\nvariable m00: Number = 0.4865709486482162;\nvariable m01: Number = 0.26566769316909306;\nvariable m02: Number = 0.1982172852343625;\n\n// Row 2\nvariable m10: Number = 0.2289745640697488;\nvariable m11: Number = 0.6917385218365064;\nvariable m12: Number = 0.079286914093745;\n\n// Row 3\nvariable m20: Number = 0.0;\nvariable m21: Number = 0.04511338185890264;\nvariable m22: Number = 1.043944368900976;\n\n// Matrix multiplication: [x, y, z] = M × [r, g, b]\nvariable x: Number = m00 * r + m01 * g + m02 * b;\nvariable y: Number = m10 * r + m11 * g + m12 * b;\nvariable z: Number = m20 * r + m21 * g + m22 * b;\n\n// Create output\nvariable output: Color.XYZD65;\noutput.x = x;\noutput.y = y;\noutput.z = z;\n\nreturn output;"
          }
        },
        {
          "source": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/oklab-color/0/",
          "target": "$self",
          "description": "Converts OKLab to XYZ-D65 using inverse LMS transformation",
          "lossless": true,
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// OKLab to XYZ-D65 Conversion\n// Reference: ColorJS oklab.js (inverse transformation)\n//\n// Algorithm:\n// 1. Apply inverse Lab-to-LMS matrix to get LMS cone responses\n// 2. Cube the LMS values (inverse of cube root)\n// 3. Apply inverse LMS-to-XYZ matrix\n//\n// Input: Color.OKLab with l, a, b perceptual coordinates\n// Output: Color.XYZD65 with x, y, z tristimulus values\n\n// Get input OKLab values\nvariable ok_l: Number = {input}.l;\nvariable ok_a: Number = {input}.a;\nvariable ok_b: Number = {input}.b;\n\n// Inverse LMStoLab_M matrix (Lab to LMS')\n// These are the inverse of the matrix used in from-xyz-d65.tokenscript\nvariable lms_l: Number = 1.0 * ok_l + 0.3963377773761749 * ok_a + 0.2158037573099136 * ok_b;\nvariable lms_m: Number = 1.0 * ok_l + -0.1055613458156586 * ok_a + -0.0638541728258133 * ok_b;\nvariable lms_s: Number = 1.0 * ok_l + -0.0894841775298119 * ok_a + -1.2914855480194092 * ok_b;\n\n// Cube the values (inverse of cube root)\nvariable lms_l_cubed: Number = lms_l * lms_l * lms_l;\nvariable lms_m_cubed: Number = lms_m * lms_m * lms_m;\nvariable lms_s_cubed: Number = lms_s * lms_s * lms_s;\n\n// Inverse XYZtoLMS_M matrix (LMS to XYZ)\n// From ColorJS oklab.js\nvariable x: Number = 1.2268798758459243 * lms_l_cubed + -0.5578149944602171 * lms_m_cubed + 0.2813910456659647 * lms_s_cubed;\nvariable y: Number = -0.0405757452148008 * lms_l_cubed + 1.1122868032803170 * lms_m_cubed + -0.0717110580655164 * lms_s_cubed;\nvariable z: Number = -0.0763729366746601 * lms_l_cubed + -0.4214933324022432 * lms_m_cubed + 1.5869240198367816 * lms_s_cubed;\n\n// Create output\nvariable output: Color.XYZD65;\noutput.x = x;\noutput.y = y;\noutput.z = z;\n\nreturn output;"
          }
        }
      ]
    }
  },
  {
    uri: "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/p3-linear-color/0/",
    schema: {
      "name": "LinearP3",
      "type": "color",
      "description": "Linear Display-P3 color space (gamma-decoded). Used for matrix transformations to XYZ.",
      "schema": {
        "type": "object",
        "properties": {
          "r": {
            "type": "number",
            "description": "Linear red channel (0-1, can exceed for HDR)"
          },
          "g": {
            "type": "number",
            "description": "Linear green channel (0-1, can exceed for HDR)"
          },
          "b": {
            "type": "number",
            "description": "Linear blue channel (0-1, can exceed for HDR)"
          }
        },
        "required": [
          "r",
          "g",
          "b"
        ],
        "order": [
          "r",
          "g",
          "b"
        ],
        "additionalProperties": false
      },
      "initializers": [
        {
          "title": "Linear P3 Color Initializer",
          "keyword": "linearp3",
          "description": "Creates a linear Display-P3 color from linear 0-1 values",
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// Linear P3 Color Initializer\n// Creates a linear Display-P3 color from linear 0-1 values\n// Input: List of [r, g, b] linear values\n\nvariable color_values: List = {input};\nvariable output: Color.LinearP3;\n\noutput.r = color_values.get(0);\noutput.g = color_values.get(1);\noutput.b = color_values.get(2);\n\nreturn output;"
          }
        }
      ],
      "conversions": [
        {
          "source": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/xyz-d65-color/0/",
          "target": "$self",
          "description": "Converts XYZ-D65 to Linear P3 using the P3 transformation matrix",
          "lossless": true,
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// XYZ-D65 to Linear P3 Conversion\n// Converts CIE XYZ (D65) to linear Display-P3 RGB\n// Reference: CSS Color Level 4 specification\n//\n// Uses the inverse of the P3 to XYZ-D65 matrix\n// Matrix values from ColorJS / CSS Color Level 4\n//\n// Input: Color.XYZD65 with x, y, z tristimulus values\n// Output: Color.LinearP3 with linear r, g, b values (may be outside 0-1 for out-of-gamut)\n\n// Get XYZ values\nvariable x: Number = {input}.x;\nvariable y: Number = {input}.y;\nvariable z: Number = {input}.z;\n\n// XYZ to Linear P3 matrix (inverse of P3 to XYZ)\n// Row 1\nvariable m00: Number = 2.4934969119414254;\nvariable m01: Number = -0.9313836179191239;\nvariable m02: Number = -0.40271078445071684;\n\n// Row 2\nvariable m10: Number = -0.8294889695615747;\nvariable m11: Number = 1.7626640603183463;\nvariable m12: Number = 0.023624685841943577;\n\n// Row 3\nvariable m20: Number = 0.03584583024378447;\nvariable m21: Number = -0.07617238926804182;\nvariable m22: Number = 0.9568845240076872;\n\n// Matrix multiplication: [r, g, b] = M × [x, y, z]\nvariable linear_r: Number = m00 * x + m01 * y + m02 * z;\nvariable linear_g: Number = m10 * x + m11 * y + m12 * z;\nvariable linear_b: Number = m20 * x + m21 * y + m22 * z;\n\n// Create output (note: values may be outside 0-1 for out-of-gamut colors)\nvariable output: Color.LinearP3;\noutput.r = linear_r;\noutput.g = linear_g;\noutput.b = linear_b;\n\nreturn output;"
          }
        }
      ]
    }
  },
  {
    uri: "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/oklab-color/0/",
    schema: {
      "name": "OKLab",
      "type": "color",
      "description": "OKLab perceptually uniform color space by Björn Ottosson. L is lightness (0-1), a is green-red axis, b is blue-yellow axis.",
      "schema": {
        "type": "object",
        "properties": {
          "l": {
            "type": "number",
            "description": "Lightness (0-1)"
          },
          "a": {
            "type": "number",
            "description": "Green-red axis (typically -0.4 to 0.4)"
          },
          "b": {
            "type": "number",
            "description": "Blue-yellow axis (typically -0.4 to 0.4)"
          }
        },
        "required": [
          "l",
          "a",
          "b"
        ],
        "order": [
          "l",
          "a",
          "b"
        ],
        "additionalProperties": false
      },
      "initializers": [
        {
          "title": "OKLab Color Initializer",
          "keyword": "oklab",
          "description": "Creates an OKLab color from L, a, b values",
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// OKLab Color Initializer\n// Creates an OKLab color from L, a, b values\n// Input: List of [l, a, b] or [l, a, b, alpha] values\n\nvariable lab_values: List = {input};\nvariable output: Color.OKLab;\n\noutput.l = lab_values.get(0);\noutput.a = lab_values.get(1);\noutput.b = lab_values.get(2);\n\n// Set alpha if provided as 4th parameter\nif (lab_values.length() > 3) [\n  output.alpha = lab_values.get(3);\n];\n\nreturn output;"
          }
        }
      ],
      "conversions": [
        {
          "source": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/xyz-d65-color/0/",
          "target": "$self",
          "description": "Converts XYZ-D65 to OKLab using Björn Ottosson's algorithm",
          "lossless": true,
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// XYZ-D65 to OKLab Conversion\n// Uses ColorJS-compatible matrices (recalculated for consistent D65 white)\n// Reference: https://github.com/color-js/color.js/blob/main/src/spaces/oklab.js\n//\n// Algorithm:\n// 1. XYZ-D65 → LMS (M1 matrix)\n// 2. LMS → LMS' (cube root transformation)\n// 3. LMS' → OKLab (M2 matrix)\n//\n// Input: Color.XYZD65 with x, y, z tristimulus\n// Output: Color.OKLab with l, a, b coordinates\n\n// Get input XYZ-D65 values\nvariable x: Number = {input}.x;\nvariable y: Number = {input}.y;\nvariable z: Number = {input}.z;\n\n// Step 1: XYZ-D65 → LMS cone response\n// ColorJS XYZtoLMS_M matrix (recalculated for consistent reference white)\nvariable lms_l: Number = x * 0.8190224379967030 + y * 0.3619062600528904 + z * -0.1288737815209879;\nvariable lms_m: Number = x * 0.0329836539323885 + y * 0.9292868615863434 + z * 0.0361446663506424;\nvariable lms_s: Number = x * 0.0481771893596242 + y * 0.2642395317527308 + z * 0.6335478284694309;\n\n// Step 2: Apply cube root (γ = 1/3)\n// Note: Using pow with 1/3 exponent (cbrt equivalent for positive values)\nvariable cube_root_exp: Number = 0.3333333333333333;\nvariable lms_l_prime: Number = pow(lms_l, cube_root_exp);\nvariable lms_m_prime: Number = pow(lms_m, cube_root_exp);\nvariable lms_s_prime: Number = pow(lms_s, cube_root_exp);\n\n// Step 3: LMS' → OKLab\n// ColorJS LMStoLab_M matrix\nvariable oklab_l: Number = lms_l_prime * 0.2104542683093140 + lms_m_prime * 0.7936177747023054 + lms_s_prime * -0.0040720430116193;\nvariable oklab_a: Number = lms_l_prime * 1.9779985324311684 + lms_m_prime * -2.4285922420485799 + lms_s_prime * 0.4505937096174110;\nvariable oklab_b: Number = lms_l_prime * 0.0259040424655478 + lms_m_prime * 0.7827717124575296 + lms_s_prime * -0.8086757549230774;\n\n// Create output\nvariable output: Color.OKLab;\noutput.l = oklab_l;\noutput.a = oklab_a;\noutput.b = oklab_b;\n\nreturn output;"
          }
        },
        {
          "source": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/oklch-color/0/",
          "target": "$self",
          "description": "Converts OKLCH to OKLab (polar to cartesian)",
          "lossless": true,
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// OKLCH to OKLab Conversion\n// Converts polar (C, H) back to cartesian (a, b) coordinates\n// Reference: Björn Ottosson's OKLab specification\n//\n// Algorithm:\n// L stays the same (lightness)\n// a = C * cos(H * π/180)\n// b = C * sin(H * π/180)\n//\n// Input: Color.OKLCH with l, c, h coordinates\n// Output: Color.OKLab with l, a, b coordinates\n\n// Get input OKLCH values\nvariable l: Number = {input}.l;\nvariable c: Number = {input}.c;\nvariable h: Number = {input}.h;\n\n// Constants\nvariable pi: Number = pi();\nvariable deg_to_rad: Number = pi / 180;\n\n// Convert hue to radians\nvariable h_rad: Number = h * deg_to_rad;\n\n// Convert polar to cartesian\nvariable a: Number = c * cos(h_rad);\nvariable b: Number = c * sin(h_rad);\n\n// Create output\nvariable output: Color.OKLab;\noutput.l = l;\noutput.a = a;\noutput.b = b;\n\nreturn output;"
          }
        },
        {
          "source": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/okhsl-color/0/",
          "target": "$self",
          "description": "Converts OKHSL to OKLab",
          "lossless": true,
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// OKHSL to OKLab Conversion\n// Reference: Björn Ottosson - \"A perceptual color picker: OKHSL and OKHSV\"\n// URL: https://bottosson.github.io/posts/colorpicker/\n// Reference: https://github.com/color-js/color.js/blob/main/src/spaces/okhsl.js\n//\n// Converts OKHSL back to OKLab using:\n// 1. Inverse toe function to recover OKLab lightness\n// 2. Cusp finding to determine max chroma at this hue\n// 3. Saturation denormalization to get actual chroma\n//\n// Input: Color.OKHSL with h (0-360), s (0-1), l (0-1)\n// Output: Color.OKLab with l (0-1), a, b coordinates\n\nvariable h: Number = input.h;\nvariable s: Number = input.s;\nvariable l: Number = input.l;\n\n// Native constants\nvariable pi_val: Number = pi();\n\n// Toe function constants\nvariable toe_k1: Number = 0.206;\nvariable toe_k2: Number = 0.03;\nvariable toe_k3: Number = 1.17009708737864;\n\n// ═══════════════════════════════════════════════════════════════════════════\n// Step 1: Apply inverse toe function to get OKLab lightness\n// toe_inv(x) = (x^2 + k1*x) / (k3 * (x + k2))\n// ═══════════════════════════════════════════════════════════════════════════\nvariable lab_l: Number = l;\nif (l > 0.0001 && l < 0.9999) [\n  lab_l = (l * l + toe_k1 * l) / (toe_k3 * (l + toe_k2));\n];\n\n// ═══════════════════════════════════════════════════════════════════════════\n// Step 2: Handle achromatic case\n// ═══════════════════════════════════════════════════════════════════════════\nvariable lab_a: Number = 0;\nvariable lab_b: Number = 0;\n\n// ═══════════════════════════════════════════════════════════════════════════\n// Step 3: Compute hue direction\n// ═══════════════════════════════════════════════════════════════════════════\nvariable h_rad: Number = h * pi_val / 180;\nvariable a_: Number = cos(h_rad);\nvariable b_: Number = sin(h_rad);\n\n// ═══════════════════════════════════════════════════════════════════════════\n// Pre-compute LMS coefficients (used in steps 4 and 5)\n// ═══════════════════════════════════════════════════════════════════════════\nvariable kl: Number = 0.3963377774 * a_ + 0.2158037573 * b_;\nvariable km: Number = -0.1055613458 * a_ - 0.0638541728 * b_;\nvariable ks: Number = -0.0894841775 * a_ - 1.2914855480 * b_;\n\n// ═══════════════════════════════════════════════════════════════════════════\n// Step 4: Find maximum saturation at this hue (same as forward conversion)\n// ═══════════════════════════════════════════════════════════════════════════\nvariable s_max: Number = 0;\n\n// Variables for LMS intermediate calculations (reused in step 5)\nvariable l_lms: Number = 0;\nvariable m_lms: Number = 0;\nvariable s_lms: Number = 0;\n\nif (s >= 0.0001) [\n  variable k0: Number = 0;\n  variable k1_coef: Number = 0;\n  variable k2_coef: Number = 0;\n  variable k3_coef: Number = 0;\n  variable k4_coef: Number = 0;\n  variable wl: Number = 0;\n  variable wm: Number = 0;\n  variable ws: Number = 0;\n  \n  variable test_r: Number = -1.88170328 * a_ - 0.80936493 * b_;\n  variable test_g: Number = 1.81444104 * a_ - 1.19445276 * b_;\n  \n  if (test_r > 1) [\n    k0 = 1.19086277;\n    k1_coef = 1.76576728;\n    k2_coef = 0.59662641;\n    k3_coef = 0.75515197;\n    k4_coef = 0.56771245;\n    wl = 4.0767416621;\n    wm = -3.3077115913;\n    ws = 0.2309699292;\n  ] else [\n    if (test_g > 1) [\n      k0 = 0.73956515;\n      k1_coef = -0.45954404;\n      k2_coef = 0.08285427;\n      k3_coef = 0.12541073;\n      k4_coef = -0.14503204;\n      wl = -1.2684380046;\n      wm = 2.6097574011;\n      ws = -0.3413193965;\n    ] else [\n      k0 = 1.35733652;\n      k1_coef = -0.00915799;\n      k2_coef = -1.15130210;\n      k3_coef = -0.50559606;\n      k4_coef = 0.00692167;\n      wl = -0.0041960863;\n      wm = -0.7034186147;\n      ws = 1.7076147010;\n    ];\n  ];\n  \n  s_max = k0 + k1_coef * a_ + k2_coef * b_ + k3_coef * a_ * a_ + k4_coef * a_ * b_;\n  \n  // Halley's method refinement\n  variable l_temp: Number = 1 + s_max * kl;\n  variable m_temp: Number = 1 + s_max * km;\n  variable s_temp: Number = 1 + s_max * ks;\n  \n  variable l_cubed: Number = l_temp * l_temp * l_temp;\n  variable m_cubed: Number = m_temp * m_temp * m_temp;\n  variable s_cubed: Number = s_temp * s_temp * s_temp;\n  \n  variable l_ds: Number = 3 * kl * l_temp * l_temp;\n  variable m_ds: Number = 3 * km * m_temp * m_temp;\n  variable s_ds: Number = 3 * ks * s_temp * s_temp;\n  \n  variable l_ds2: Number = 6 * kl * kl * l_temp;\n  variable m_ds2: Number = 6 * km * km * m_temp;\n  variable s_ds2: Number = 6 * ks * ks * s_temp;\n  \n  variable f: Number = wl * l_cubed + wm * m_cubed + ws * s_cubed;\n  variable f1: Number = wl * l_ds + wm * m_ds + ws * s_ds;\n  variable f2: Number = wl * l_ds2 + wm * m_ds2 + ws * s_ds2;\n  \n  variable denom: Number = f1 * f1 - 0.5 * f * f2;\n  if (abs(denom) > 0.000001) [\n    s_max = s_max - f * f1 / denom;\n  ];\n];\n\n// ═══════════════════════════════════════════════════════════════════════════\n// Step 5: Find cusp\n// ═══════════════════════════════════════════════════════════════════════════\nvariable l_cusp: Number = 1;\nvariable c_cusp: Number = 0;\n\nif (s >= 0.0001 && s_max > 0) [\n  // Recompute LMS values with refined s_max (kl, km, ks already computed)\n  variable l_cusp_temp: Number = 1 + s_max * kl;\n  variable m_cusp_temp: Number = 1 + s_max * km;\n  variable s_cusp_temp: Number = 1 + s_max * ks;\n  \n  l_lms = l_cusp_temp * l_cusp_temp * l_cusp_temp;\n  m_lms = m_cusp_temp * m_cusp_temp * m_cusp_temp;\n  s_lms = s_cusp_temp * s_cusp_temp * s_cusp_temp;\n  \n  variable r_lin: Number = 4.0767416621 * l_lms - 3.3077115913 * m_lms + 0.2309699292 * s_lms;\n  variable g_lin: Number = -1.2684380046 * l_lms + 2.6097574011 * m_lms - 0.3413193965 * s_lms;\n  variable b_lin: Number = -0.0041960863 * l_lms - 0.7034186147 * m_lms + 1.7076147010 * s_lms;\n  \n  variable max_rgb: Number = r_lin;\n  if (g_lin > max_rgb) [ max_rgb = g_lin; ];\n  if (b_lin > max_rgb) [ max_rgb = b_lin; ];\n  \n  if (max_rgb > 0) [\n    l_cusp = pow(1 / max_rgb, 0.3333333333333333);\n    c_cusp = l_cusp * s_max;\n  ];\n];\n\n// ═══════════════════════════════════════════════════════════════════════════\n// Step 6: Compute chroma from saturation\n// ═══════════════════════════════════════════════════════════════════════════\nvariable c: Number = 0;\n\nif (s >= 0.0001 && l_cusp > 0.0001 && c_cusp > 0.0001) [\n  variable s_t_cusp: Number = c_cusp / l_cusp;\n  \n  // Denormalize saturation to get chroma\n  c = s * lab_l * s_t_cusp;\n];\n\n// ═══════════════════════════════════════════════════════════════════════════\n// Step 7: Convert polar to cartesian\n// ═══════════════════════════════════════════════════════════════════════════\nif (s >= 0.0001) [\n  lab_a = c * a_;\n  lab_b = c * b_;\n];\n\n// ═══════════════════════════════════════════════════════════════════════════\n// Output\n// ═══════════════════════════════════════════════════════════════════════════\nvariable output: Color.OKLab;\noutput.l = lab_l;\noutput.a = lab_a;\noutput.b = lab_b;\noutput"
          }
        },
        {
          "source": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/okhsv-color/0/",
          "target": "$self",
          "description": "Converts OKHSV to OKLab",
          "lossless": true,
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// OKHSV to OKLab Conversion\n// Reference: Björn Ottosson - \"A perceptual color picker: OKHSL and OKHSV\"\n// URL: https://bottosson.github.io/posts/colorpicker/\n// Reference: https://github.com/color-js/color.js/blob/main/src/spaces/okhsv.js\n//\n// Converts OKHSV back to OKLab using:\n// 1. Cusp finding to determine gamut boundary at this hue\n// 2. V and S denormalization to get L and C\n//\n// Input: Color.OKHSV with h (0-360), s (0-1), v (0-1)\n// Output: Color.OKLab with l (0-1), a, b coordinates\n\nvariable h: Number = input.h;\nvariable s: Number = input.s;\nvariable v: Number = input.v;\n\n// Native constants\nvariable pi_val: Number = pi();\n\n// ═══════════════════════════════════════════════════════════════════════════\n// Step 1: Handle edge cases\n// ═══════════════════════════════════════════════════════════════════════════\nvariable lab_l: Number = v;\nvariable lab_a: Number = 0;\nvariable lab_b: Number = 0;\n\n// ═══════════════════════════════════════════════════════════════════════════\n// Step 2: Compute hue direction\n// ═══════════════════════════════════════════════════════════════════════════\nvariable h_rad: Number = h * pi_val / 180;\nvariable a_: Number = cos(h_rad);\nvariable b_: Number = sin(h_rad);\n\n// ═══════════════════════════════════════════════════════════════════════════\n// Pre-compute LMS coefficients (used in steps 3 and 4)\n// ═══════════════════════════════════════════════════════════════════════════\nvariable kl: Number = 0.3963377774 * a_ + 0.2158037573 * b_;\nvariable km: Number = -0.1055613458 * a_ - 0.0638541728 * b_;\nvariable ks: Number = -0.0894841775 * a_ - 1.2914855480 * b_;\n\n// ═══════════════════════════════════════════════════════════════════════════\n// Step 3: Find maximum saturation at this hue\n// ═══════════════════════════════════════════════════════════════════════════\nvariable s_max: Number = 0;\n\n// Variables for LMS intermediate calculations (reused in step 4)\nvariable l_lms: Number = 0;\nvariable m_lms: Number = 0;\nvariable s_lms: Number = 0;\n\nif (s >= 0.0001 && v >= 0.0001) [\n  variable k0: Number = 0;\n  variable k1_coef: Number = 0;\n  variable k2_coef: Number = 0;\n  variable k3_coef: Number = 0;\n  variable k4_coef: Number = 0;\n  variable wl: Number = 0;\n  variable wm: Number = 0;\n  variable ws: Number = 0;\n  \n  variable test_r: Number = -1.88170328 * a_ - 0.80936493 * b_;\n  variable test_g: Number = 1.81444104 * a_ - 1.19445276 * b_;\n  \n  if (test_r > 1) [\n    k0 = 1.19086277;\n    k1_coef = 1.76576728;\n    k2_coef = 0.59662641;\n    k3_coef = 0.75515197;\n    k4_coef = 0.56771245;\n    wl = 4.0767416621;\n    wm = -3.3077115913;\n    ws = 0.2309699292;\n  ] else [\n    if (test_g > 1) [\n      k0 = 0.73956515;\n      k1_coef = -0.45954404;\n      k2_coef = 0.08285427;\n      k3_coef = 0.12541073;\n      k4_coef = -0.14503204;\n      wl = -1.2684380046;\n      wm = 2.6097574011;\n      ws = -0.3413193965;\n    ] else [\n      k0 = 1.35733652;\n      k1_coef = -0.00915799;\n      k2_coef = -1.15130210;\n      k3_coef = -0.50559606;\n      k4_coef = 0.00692167;\n      wl = -0.0041960863;\n      wm = -0.7034186147;\n      ws = 1.7076147010;\n    ];\n  ];\n  \n  s_max = k0 + k1_coef * a_ + k2_coef * b_ + k3_coef * a_ * a_ + k4_coef * a_ * b_;\n  \n  // Halley's method refinement\n  variable l_temp: Number = 1 + s_max * kl;\n  variable m_temp: Number = 1 + s_max * km;\n  variable s_temp: Number = 1 + s_max * ks;\n  \n  variable l_cubed: Number = l_temp * l_temp * l_temp;\n  variable m_cubed: Number = m_temp * m_temp * m_temp;\n  variable s_cubed: Number = s_temp * s_temp * s_temp;\n  \n  variable l_ds: Number = 3 * kl * l_temp * l_temp;\n  variable m_ds: Number = 3 * km * m_temp * m_temp;\n  variable s_ds: Number = 3 * ks * s_temp * s_temp;\n  \n  variable l_ds2: Number = 6 * kl * kl * l_temp;\n  variable m_ds2: Number = 6 * km * km * m_temp;\n  variable s_ds2: Number = 6 * ks * ks * s_temp;\n  \n  variable f: Number = wl * l_cubed + wm * m_cubed + ws * s_cubed;\n  variable f1: Number = wl * l_ds + wm * m_ds + ws * s_ds;\n  variable f2: Number = wl * l_ds2 + wm * m_ds2 + ws * s_ds2;\n  \n  variable denom: Number = f1 * f1 - 0.5 * f * f2;\n  if (abs(denom) > 0.000001) [\n    s_max = s_max - f * f1 / denom;\n  ];\n];\n\n// ═══════════════════════════════════════════════════════════════════════════\n// Step 4: Find cusp\n// ═══════════════════════════════════════════════════════════════════════════\nvariable l_cusp: Number = 1;\nvariable c_cusp: Number = 0;\n\nif (s >= 0.0001 && v >= 0.0001 && s_max > 0) [\n  // Recompute LMS values with refined s_max (kl, km, ks already computed)\n  variable l_cusp_temp: Number = 1 + s_max * kl;\n  variable m_cusp_temp: Number = 1 + s_max * km;\n  variable s_cusp_temp: Number = 1 + s_max * ks;\n  \n  l_lms = l_cusp_temp * l_cusp_temp * l_cusp_temp;\n  m_lms = m_cusp_temp * m_cusp_temp * m_cusp_temp;\n  s_lms = s_cusp_temp * s_cusp_temp * s_cusp_temp;\n  \n  variable r_lin: Number = 4.0767416621 * l_lms - 3.3077115913 * m_lms + 0.2309699292 * s_lms;\n  variable g_lin: Number = -1.2684380046 * l_lms + 2.6097574011 * m_lms - 0.3413193965 * s_lms;\n  variable b_lin: Number = -0.0041960863 * l_lms - 0.7034186147 * m_lms + 1.7076147010 * s_lms;\n  \n  variable max_rgb: Number = r_lin;\n  if (g_lin > max_rgb) [ max_rgb = g_lin; ];\n  if (b_lin > max_rgb) [ max_rgb = b_lin; ];\n  \n  if (max_rgb > 0) [\n    l_cusp = pow(1 / max_rgb, 0.3333333333333333);\n    c_cusp = l_cusp * s_max;\n  ];\n];\n\n// ═══════════════════════════════════════════════════════════════════════════\n// Step 5: Compute L and C from V and S\n// ═══════════════════════════════════════════════════════════════════════════\nvariable c: Number = 0;\n\nif (s >= 0.0001 && v >= 0.0001 && l_cusp > 0.0001 && c_cusp > 0.0001) [\n  variable s_t_cusp: Number = c_cusp / l_cusp;\n  variable t_t_cusp: Number = c_cusp / (1 - l_cusp + 0.0001);\n  \n  // Compute max chroma at this V\n  variable c_max_at_v: Number = 0;\n  \n  if (v <= l_cusp) [\n    c_max_at_v = v * s_t_cusp;\n  ] else [\n    c_max_at_v = (1 - v) * t_t_cusp;\n  ];\n  \n  // Compute actual chroma\n  c = s * c_max_at_v;\n  \n  // Compute L from V and C\n  // Reverse of: V = L + C / s_t_cusp\n  lab_l = v - c / (s_t_cusp + 0.0001);\n  if (lab_l < 0) [ lab_l = 0; ];\n  if (lab_l > 1) [ lab_l = 1; ];\n];\n\n// ═══════════════════════════════════════════════════════════════════════════\n// Step 6: Convert polar to cartesian\n// ═══════════════════════════════════════════════════════════════════════════\nif (s >= 0.0001 && v >= 0.0001) [\n  lab_a = c * a_;\n  lab_b = c * b_;\n];\n\n// ═══════════════════════════════════════════════════════════════════════════\n// Output\n// ═══════════════════════════════════════════════════════════════════════════\nvariable output: Color.OKLab;\noutput.l = lab_l;\noutput.a = lab_a;\noutput.b = lab_b;\noutput"
          }
        }
      ]
    }
  },
  {
    uri: "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/oklch-color/0/",
    schema: {
      "name": "OKLCH",
      "type": "color",
      "description": "OKLCH color space - the polar form of OKLab. L is lightness (0-1), C is chroma, H is hue angle (0-360).",
      "schema": {
        "type": "object",
        "properties": {
          "l": {
            "type": "number",
            "description": "Lightness (0-1)"
          },
          "c": {
            "type": "number",
            "description": "Chroma (0 to ~0.4 for sRGB gamut)"
          },
          "h": {
            "type": "number",
            "description": "Hue angle (0-360 degrees)"
          }
        },
        "required": [
          "l",
          "c",
          "h"
        ],
        "order": [
          "l",
          "c",
          "h"
        ],
        "additionalProperties": false
      },
      "initializers": [
        {
          "title": "OKLCH Color Initializer",
          "keyword": "oklch",
          "description": "Creates an OKLCH color from L, C, H values",
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// OKLCH Color Initializer\n// Creates an OKLCH color from L, C, H values\n// Input: List of [l, c, h] or [l, c, h, alpha] values\n\nvariable lch_values: List = {input};\nvariable output: Color.OKLCH;\n\noutput.l = lch_values.get(0);\noutput.c = lch_values.get(1);\noutput.h = lch_values.get(2);\n\n// Set alpha if provided as 4th parameter\nif (lch_values.length() > 3) [\n  output.alpha = lch_values.get(3);\n];\n\nreturn output;"
          }
        }
      ],
      "conversions": [
        {
          "source": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/oklab-color/0/",
          "target": "$self",
          "description": "Converts OKLab to OKLCH using Cartesian to polar transformation",
          "lossless": true,
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// OKLab to OKLCH Conversion\n// Converts Cartesian (a, b) to polar (C, H) coordinates\n// Reference: Björn Ottosson's OKLab specification\n//\n// Algorithm:\n// L stays the same (lightness)\n// C = sqrt(a² + b²) (chroma - distance from neutral axis)\n// H = atan2(b, a) * 180/π (hue angle in degrees)\n//\n// Input: Color.OKLab with l, a, b coordinates\n// Output: Color.OKLCH with l, c, h coordinates\n\n// Get input OKLab values\nvariable l: Number = {input}.l;\nvariable a: Number = {input}.a;\nvariable b: Number = {input}.b;\n\n// Constants\nvariable pi: Number = pi();\nvariable rad_to_deg: Number = 180 / pi;\n\n// Calculate chroma (distance from neutral axis)\nvariable c: Number = sqrt(a * a + b * b);\n\n// Calculate hue angle using atan2\n// atan2(y, x) returns angle in radians from -π to π\nvariable h_rad: Number = atan2(b, a);\nvariable h: Number = h_rad * rad_to_deg;\n\n// Normalize hue to 0-360 range\nif (h < 0) [\n    h = h + 360;\n];\n\n// Create output\nvariable output: Color.OKLCH;\noutput.l = l;\noutput.c = c;\noutput.h = h;\n\nreturn output;"
          }
        }
      ]
    }
  },
  {
    uri: "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/okhsl-color/0/",
    schema: {
      "name": "OKHSL",
      "type": "color",
      "description": "OKHSL color space by Björn Ottosson - a perceptually uniform HSL based on OKLab. H is hue (0-360), S is saturation (0-1, normalized to sRGB gamut), L is lightness (0-1). Reference: https://bottosson.github.io/posts/colorpicker/",
      "schema": {
        "type": "object",
        "properties": {
          "h": {
            "type": "number",
            "description": "Hue angle (0-360 degrees), same as OKLCH hue"
          },
          "s": {
            "type": "number",
            "description": "Saturation (0-1), normalized relative to sRGB gamut boundary"
          },
          "l": {
            "type": "number",
            "description": "Lightness (0-1), perceptually uniform with toe function applied"
          }
        },
        "required": [
          "h",
          "s",
          "l"
        ],
        "order": [
          "h",
          "s",
          "l"
        ],
        "additionalProperties": false
      },
      "initializers": [
        {
          "title": "OKHSL Color Initializer",
          "keyword": "okhsl",
          "description": "Creates an OKHSL color from H, S, L values",
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// OKHSL Color Initializer\n// Reference: Björn Ottosson - \"A perceptual color picker: OKHSL and OKHSV\"\n// URL: https://bottosson.github.io/posts/colorpicker/\n//\n// Creates an OKHSL color from hue, saturation, and lightness values.\n// OKHSL is a perceptually uniform version of HSL built on OKLab.\n//\n// Parameters:\n// - h: Hue angle (0-360 degrees), same as OKLCH hue\n// - s: Saturation (0-1), normalized to sRGB gamut boundary\n// - l: Lightness (0-1), perceptually uniform with toe function\n// - alpha: Optional alpha channel (0-1)\n//\n// Input: Object with h, s, l, and optional alpha properties\n// Output: Color.OKHSL\n\nvariable h: Number = input.h;\nvariable s: Number = input.s;\nvariable l: Number = input.l;\n\nvariable output: Color.OKHSL;\noutput.h = h;\noutput.s = s;\noutput.l = l;\n\n// Set alpha if provided\nif (input.alpha != null) [\n  output.alpha = input.alpha;\n];\n\noutput"
          }
        }
      ],
      "conversions": [
        {
          "source": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/oklab-color/0/",
          "target": "$self",
          "description": "Converts OKLab to OKHSL using Ottosson's algorithm with Halley's method refinement for gamut boundary",
          "lossless": true,
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// OKLab to OKHSL Conversion\n// Reference: Björn Ottosson - \"A perceptual color picker: OKHSL and OKHSV\"\n// URL: https://bottosson.github.io/posts/colorpicker/\n// Reference: https://github.com/color-js/color.js/blob/main/src/spaces/okhsl.js\n// Reference: https://bottosson.github.io/posts/oklab/ (original OKLab paper)\n//\n// OKHSL provides a perceptually uniform HSL with proper saturation scaling.\n// The algorithm uses three key chroma values (C_0, C_mid, C_max) and\n// performs piecewise interpolation to map chroma to saturation.\n//\n// This implementation includes the FULL findGamutIntersection algorithm\n// with Halley's method refinement for accurate gamut boundary detection.\n//\n// Input: Color.OKLab with l (0-1), a, b coordinates\n// Output: Color.OKHSL with h (0-360), s (0-1), l (0-1)\n\nvariable lab_l: Number = input.l;\nvariable lab_a: Number = input.a;\nvariable lab_b: Number = input.b;\n\n// Native constants\nvariable pi_val: Number = pi();\nvariable float_max: Number = 999999999;\n\n// Toe function constants\n// K3 = (1 + K1) / (1 + K2)\nvariable toe_k1: Number = 0.206;\nvariable toe_k2: Number = 0.03;\nvariable toe_k3: Number = 1.17009708737864;\n\n// LMS to OKLab matrix coefficients (LabtoLMS_M columns 1,2)\nvariable lab_lms_kl_a: Number = 0.3963377774;\nvariable lab_lms_kl_b: Number = 0.2158037573;\nvariable lab_lms_km_a: Number = -0.1055613458;\nvariable lab_lms_km_b: Number = -0.0638541728;\nvariable lab_lms_ks_a: Number = -0.0894841775;\nvariable lab_lms_ks_b: Number = -1.2914855480;\n\n// LMS to sRGB-linear matrix\nvariable lms_r0: Number = 4.0767416360759583;\nvariable lms_r1: Number = -3.3077115392580629;\nvariable lms_r2: Number = 0.2309699031821043;\nvariable lms_g0: Number = -1.2684379732850315;\nvariable lms_g1: Number = 2.6097573492876882;\nvariable lms_g2: Number = -0.3413193760026570;\nvariable lms_b0: Number = -0.0041960761386756;\nvariable lms_b1: Number = -0.7034186179359362;\nvariable lms_b2: Number = 1.7076146940746117;\n\n// RGB limit coefficients for determining which channel clips first\nvariable red_limit_a: Number = -1.8817031;\nvariable red_limit_b: Number = -0.80936501;\nvariable green_limit_a: Number = 1.8144408;\nvariable green_limit_b: Number = -1.19445267;\n\n// Red Kn coefficients\nvariable red_k0: Number = 1.19086277;\nvariable red_k1: Number = 1.76576728;\nvariable red_k2: Number = 0.59662641;\nvariable red_k3: Number = 0.75515197;\nvariable red_k4: Number = 0.56771245;\n\n// Green Kn coefficients\nvariable green_k0: Number = 0.73956515;\nvariable green_k1: Number = -0.45954404;\nvariable green_k2: Number = 0.08285427;\nvariable green_k3: Number = 0.12541073;\nvariable green_k4: Number = -0.14503204;\n\n// Blue Kn coefficients\nvariable blue_k0: Number = 1.35733652;\nvariable blue_k1: Number = -0.00915799;\nvariable blue_k2: Number = -1.1513021;\nvariable blue_k3: Number = -0.50559606;\nvariable blue_k4: Number = 0.00692167;\n\n// ═══════════════════════════════════════════════════════════════════════════\n// Step 1: Convert to polar coordinates and apply toe function\n// ═══════════════════════════════════════════════════════════════════════════\nvariable c: Number = sqrt(lab_a * lab_a + lab_b * lab_b);\n\n// Apply toe function: toe(x) = 0.5 * (k3*x - k1 + sqrt((k3*x - k1)^2 + 4*k2*k3*x))\nvariable l: Number = lab_l;\nif (lab_l > 0.0001 && lab_l < 0.9999) [\n  variable term: Number = toe_k3 * lab_l - toe_k1;\n  l = 0.5 * (term + sqrt(term * term + 4 * toe_k2 * toe_k3 * lab_l));\n];\n\n// Compute hue using atan2(-b, -a) + 0.5 (ColorJS convention)\nvariable h: Number = 0;\nif (c > 0.00001) [\n  variable h_normalized: Number = 0.5 + atan2(-lab_b, -lab_a) / (2 * pi_val);\n  h = h_normalized * 360;\n  if (h < 0) [ h = h + 360; ];\n  if (h >= 360) [ h = h - 360; ];\n];\n\n// Initialize saturation\nvariable s: Number = 0;\n\n// ═══════════════════════════════════════════════════════════════════════════\n// Step 2: Check if chromatic (non-achromatic, non-edge)\n// ═══════════════════════════════════════════════════════════════════════════\nvariable is_chromatic: Number = 1;\nif (c < 0.00001) [ is_chromatic = 0; ];\nif (l < 0.0001) [ is_chromatic = 0; ];\nif (l > 0.9999) [ is_chromatic = 0; ];\n\nif (is_chromatic > 0.5) [\n  // ═══════════════════════════════════════════════════════════════════════\n  // Step 3: Normalize hue direction (a_, b_)\n  // ═══════════════════════════════════════════════════════════════════════\n  variable a_: Number = lab_a / c;\n  variable b_: Number = lab_b / c;\n  \n  // Pre-compute LMS coefficients\n  variable kl: Number = lab_lms_kl_a * a_ + lab_lms_kl_b * b_;\n  variable km: Number = lab_lms_km_a * a_ + lab_lms_km_b * b_;\n  variable ks: Number = lab_lms_ks_a * a_ + lab_lms_ks_b * b_;\n  \n  // ═══════════════════════════════════════════════════════════════════════\n  // Step 4: computeMaxSaturation - Find S_max for this hue\n  // ═══════════════════════════════════════════════════════════════════════\n  variable test_red: Number = red_limit_a * a_ + red_limit_b * b_;\n  variable test_green: Number = green_limit_a * a_ + green_limit_b * b_;\n  \n  variable k0: Number = blue_k0;\n  variable k1_coef: Number = blue_k1;\n  variable k2_coef: Number = blue_k2;\n  variable k3_coef: Number = blue_k3;\n  variable k4_coef: Number = blue_k4;\n  variable wl: Number = lms_b0;\n  variable wm: Number = lms_b1;\n  variable ws: Number = lms_b2;\n  \n  if (test_red > 1) [\n    k0 = red_k0; k1_coef = red_k1; k2_coef = red_k2; k3_coef = red_k3; k4_coef = red_k4;\n    wl = lms_r0; wm = lms_r1; ws = lms_r2;\n  ] else [\n    if (test_green > 1) [\n      k0 = green_k0; k1_coef = green_k1; k2_coef = green_k2; k3_coef = green_k3; k4_coef = green_k4;\n      wl = lms_g0; wm = lms_g1; ws = lms_g2;\n    ];\n  ];\n  \n  // Polynomial approximation\n  variable s_max: Number = k0 + k1_coef * a_ + k2_coef * b_ + k3_coef * a_ * a_ + k4_coef * a_ * b_;\n  \n  // Halley's method refinement for s_max\n  variable l_temp: Number = 1 + s_max * kl;\n  variable m_temp: Number = 1 + s_max * km;\n  variable s_temp: Number = 1 + s_max * ks;\n  \n  variable l_cubed: Number = l_temp * l_temp * l_temp;\n  variable m_cubed: Number = m_temp * m_temp * m_temp;\n  variable s_cubed: Number = s_temp * s_temp * s_temp;\n  \n  variable l_ds: Number = 3 * kl * l_temp * l_temp;\n  variable m_ds: Number = 3 * km * m_temp * m_temp;\n  variable s_ds: Number = 3 * ks * s_temp * s_temp;\n  \n  variable l_ds2: Number = 6 * kl * kl * l_temp;\n  variable m_ds2: Number = 6 * km * km * m_temp;\n  variable s_ds2: Number = 6 * ks * ks * s_temp;\n  \n  variable f: Number = wl * l_cubed + wm * m_cubed + ws * s_cubed;\n  variable f1: Number = wl * l_ds + wm * m_ds + ws * s_ds;\n  variable f2: Number = wl * l_ds2 + wm * m_ds2 + ws * s_ds2;\n  \n  variable halley_denom: Number = f1 * f1 - 0.5 * f * f2;\n  if (abs(halley_denom) > 0.000001) [\n    s_max = s_max - f * f1 / halley_denom;\n  ];\n  \n  // ═══════════════════════════════════════════════════════════════════════\n  // Step 5: findCusp - Get L_cusp and C_cusp\n  // ═══════════════════════════════════════════════════════════════════════\n  variable l_cusp: Number = 1;\n  variable c_cusp: Number = 0;\n  \n  if (s_max > 0) [\n    variable cusp_l_: Number = 1 + s_max * kl;\n    variable cusp_m_: Number = 1 + s_max * km;\n    variable cusp_s_: Number = 1 + s_max * ks;\n    \n    variable cusp_l: Number = cusp_l_ * cusp_l_ * cusp_l_;\n    variable cusp_m: Number = cusp_m_ * cusp_m_ * cusp_m_;\n    variable cusp_s: Number = cusp_s_ * cusp_s_ * cusp_s_;\n    \n    variable cusp_r: Number = lms_r0 * cusp_l + lms_r1 * cusp_m + lms_r2 * cusp_s;\n    variable cusp_g: Number = lms_g0 * cusp_l + lms_g1 * cusp_m + lms_g2 * cusp_s;\n    variable cusp_b: Number = lms_b0 * cusp_l + lms_b1 * cusp_m + lms_b2 * cusp_s;\n    \n    variable max_rgb: Number = cusp_r;\n    if (cusp_g > max_rgb) [ max_rgb = cusp_g; ];\n    if (cusp_b > max_rgb) [ max_rgb = cusp_b; ];\n    if (max_rgb < 0.0001) [ max_rgb = 0.0001; ];\n    \n    l_cusp = pow(1 / max_rgb, 0.3333333333333333);\n    c_cusp = l_cusp * s_max;\n  ];\n  \n  // ═══════════════════════════════════════════════════════════════════════\n  // Step 6: findGamutIntersection - Find C_max at current L\n  // This is the FULL algorithm with Halley's method for upper half\n  //\n  // Finds intersection of line: L = L0*(1-t) + t*L1, C = t*C1\n  // where L0=L1=lab_l and C1=1 (seeking max chroma at this L)\n  // ═══════════════════════════════════════════════════════════════════════\n  variable c_max: Number = 0;\n  \n  if (l_cusp > 0.0001 && c_cusp > 0.0001) [\n    // Parameters for gamut intersection: l1=lab_l, c1=1, l0=lab_l\n    variable l1: Number = lab_l;\n    variable c1: Number = 1;\n    variable l0: Number = lab_l;\n    \n    // Check which half: (l1 - l0) * c_cusp - (l_cusp - l0) * c1\n    // Since l1 = l0 = lab_l, this simplifies to: -(l_cusp - lab_l) * 1 = lab_l - l_cusp\n    variable half_test: Number = lab_l - l_cusp;\n    variable t_intersect: Number = 0;\n    \n    if (half_test <= 0) [\n      // Lower half (below cusp) - simple triangle intersection\n      // t = (c_cusp * l0) / (c1 * l_cusp + c_cusp * (l0 - l1))\n      // Since l0 = l1, denominator = c1 * l_cusp = l_cusp\n      variable lower_denom: Number = l_cusp;\n      if (abs(lower_denom) > 0.00001) [\n        t_intersect = (c_cusp * lab_l) / lower_denom;\n      ];\n    ] else [\n      // Upper half (above cusp) - triangle + Halley's method\n      // First: triangle intersection\n      // t = (c_cusp * (l0 - 1)) / (c1 * (l_cusp - 1) + c_cusp * (l0 - l1))\n      // Since l0 = l1 = lab_l: t = (c_cusp * (lab_l - 1)) / (l_cusp - 1)\n      variable upper_denom: Number = l_cusp - 1;\n      if (abs(upper_denom) > 0.00001) [\n        t_intersect = c_cusp * (lab_l - 1) / upper_denom;\n      ];\n      \n      // Halley's method refinement for upper half\n      // dl = l1 - l0 = 0, dc = c1 = 1\n      variable dl: Number = 0;\n      variable dc: Number = 1;\n      \n      variable ldt_: Number = dl + dc * kl;\n      variable mdt_: Number = dl + dc * km;\n      variable sdt_: Number = dl + dc * ks;\n      \n      // Compute L and C at current t\n      variable L_at_t: Number = l0 * (1 - t_intersect) + t_intersect * l1;\n      variable C_at_t: Number = t_intersect * c1;\n      \n      // LMS values at (L, C)\n      variable l_at: Number = L_at_t + C_at_t * kl;\n      variable m_at: Number = L_at_t + C_at_t * km;\n      variable s_at: Number = L_at_t + C_at_t * ks;\n      \n      variable l_lms: Number = l_at * l_at * l_at;\n      variable m_lms: Number = m_at * m_at * m_at;\n      variable s_lms: Number = s_at * s_at * s_at;\n      \n      // First derivatives\n      variable ldt: Number = 3 * ldt_ * l_at * l_at;\n      variable mdt: Number = 3 * mdt_ * m_at * m_at;\n      variable sdt: Number = 3 * sdt_ * s_at * s_at;\n      \n      // Second derivatives\n      variable ldt2: Number = 6 * ldt_ * ldt_ * l_at;\n      variable mdt2: Number = 6 * mdt_ * mdt_ * m_at;\n      variable sdt2: Number = 6 * sdt_ * sdt_ * s_at;\n      \n      // Red channel Halley step\n      variable r_val: Number = lms_r0 * l_lms + lms_r1 * m_lms + lms_r2 * s_lms - 1;\n      variable r1: Number = lms_r0 * ldt + lms_r1 * mdt + lms_r2 * sdt;\n      variable r2: Number = lms_r0 * ldt2 + lms_r1 * mdt2 + lms_r2 * sdt2;\n      variable r_denom: Number = r1 * r1 - 0.5 * r_val * r2;\n      variable ur: Number = 0;\n      variable tr: Number = float_max;\n      if (abs(r_denom) > 0.000001) [\n        ur = r1 / r_denom;\n        if (ur >= 0) [ tr = -r_val * ur; ];\n      ];\n      \n      // Green channel Halley step\n      variable g_val: Number = lms_g0 * l_lms + lms_g1 * m_lms + lms_g2 * s_lms - 1;\n      variable g1: Number = lms_g0 * ldt + lms_g1 * mdt + lms_g2 * sdt;\n      variable g2: Number = lms_g0 * ldt2 + lms_g1 * mdt2 + lms_g2 * sdt2;\n      variable g_denom: Number = g1 * g1 - 0.5 * g_val * g2;\n      variable ug: Number = 0;\n      variable tg: Number = float_max;\n      if (abs(g_denom) > 0.000001) [\n        ug = g1 / g_denom;\n        if (ug >= 0) [ tg = -g_val * ug; ];\n      ];\n      \n      // Blue channel Halley step\n      variable b_val: Number = lms_b0 * l_lms + lms_b1 * m_lms + lms_b2 * s_lms - 1;\n      variable b1: Number = lms_b0 * ldt + lms_b1 * mdt + lms_b2 * sdt;\n      variable b2: Number = lms_b0 * ldt2 + lms_b1 * mdt2 + lms_b2 * sdt2;\n      variable b_denom: Number = b1 * b1 - 0.5 * b_val * b2;\n      variable ub: Number = 0;\n      variable tb: Number = float_max;\n      if (abs(b_denom) > 0.000001) [\n        ub = b1 / b_denom;\n        if (ub >= 0) [ tb = -b_val * ub; ];\n      ];\n      \n      // Take minimum of the three corrections\n      variable t_correction: Number = tr;\n      if (tg < t_correction) [ t_correction = tg; ];\n      if (tb < t_correction) [ t_correction = tb; ];\n      if (t_correction < float_max) [\n        t_intersect = t_intersect + t_correction;\n      ];\n    ];\n    \n    // C_max = t * c1 = t (since c1 = 1)\n    c_max = t_intersect;\n    if (c_max < 0) [ c_max = 0; ];\n  ];\n  \n  // ═══════════════════════════════════════════════════════════════════════\n  // Step 7: getStMid - Polynomial approximation for mid-saturation ST\n  // ═══════════════════════════════════════════════════════════════════════\n  variable st_mid_s: Number = 0.11516993 + 1 / (\n    7.44778970 + 4.15901240 * b_ +\n    a_ * (-2.19557347 + 1.75198401 * b_ +\n      a_ * (-2.13704948 - 10.02301043 * b_ +\n        a_ * (-4.24894561 + 5.38770819 * b_ + 4.69891013 * a_))));\n  \n  variable st_mid_t: Number = 0.11239642 + 1 / (\n    1.61320320 - 0.68124379 * b_ +\n    a_ * (0.40370612 + 0.90148123 * b_ +\n      a_ * (-0.27087943 + 0.61223990 * b_ +\n        a_ * (0.00299215 - 0.45399568 * b_ - 0.14661872 * a_))));\n  \n  // ═══════════════════════════════════════════════════════════════════════\n  // Step 8: getCs - Compute C_0, C_mid, C_max with scale factor k\n  // ═══════════════════════════════════════════════════════════════════════\n  variable st_max_s: Number = c_cusp / (l_cusp + 0.0001);\n  variable st_max_t: Number = c_cusp / (1 - l_cusp + 0.0001);\n  \n  // Scale factor k = c_max / min(L * st_max_s, (1-L) * st_max_t)\n  variable min_st: Number = lab_l * st_max_s;\n  variable min_st_t: Number = (1 - lab_l) * st_max_t;\n  if (min_st_t < min_st) [ min_st = min_st_t; ];\n  \n  variable k_factor: Number = 1;\n  if (min_st > 0.0001 && c_max > 0.0001) [\n    k_factor = c_max / min_st;\n  ];\n  \n  // C_mid = 0.9 * k * sqrt(sqrt(1 / (1/ca^4 + 1/cb^4)))\n  variable ca: Number = lab_l * st_mid_s;\n  variable cb: Number = (1 - lab_l) * st_mid_t;\n  variable ca4: Number = ca * ca * ca * ca;\n  variable cb4: Number = cb * cb * cb * cb;\n  variable c_mid: Number = 0;\n  if (ca4 > 0.0000001 && cb4 > 0.0000001) [\n    c_mid = 0.9 * k_factor * sqrt(sqrt(1 / (1 / ca4 + 1 / cb4)));\n  ];\n  \n  // C_0 using average ST values (0.4, 0.8)\n  variable ca0: Number = lab_l * 0.4;\n  variable cb0: Number = (1 - lab_l) * 0.8;\n  variable ca0_sq: Number = ca0 * ca0;\n  variable cb0_sq: Number = cb0 * cb0;\n  variable c_0: Number = 0;\n  if (ca0_sq > 0.0000001 && cb0_sq > 0.0000001) [\n    c_0 = sqrt(1 / (1 / ca0_sq + 1 / cb0_sq));\n  ];\n  \n  // ═══════════════════════════════════════════════════════════════════════\n  // Step 9: Compute saturation using piecewise interpolation\n  // ═══════════════════════════════════════════════════════════════════════\n  variable mid: Number = 0.8;\n  \n  if (c < c_mid && c_mid > 0.0001 && c_0 > 0.0001) [\n    // Below mid-point: s = t * 0.8 where t = c / (k1 + k2*c)\n    variable k1_low: Number = mid * c_0;\n    variable k2_low: Number = 1 - k1_low / c_mid;\n    variable t_low: Number = c / (k1_low + k2_low * c + 0.0001);\n    s = t_low * mid;\n  ] else [\n    if (c_mid > 0.0001 && c_0 > 0.0001 && c_max > c_mid) [\n      // Above mid-point: s = 0.8 + 0.2 * t where t = (c - c_mid) / (k1 + k2*(c - c_mid))\n      variable mid_inv: Number = 1.25;\n      variable k0_high: Number = c_mid;\n      variable k1_high: Number = 0.2 * c_mid * c_mid * mid_inv * mid_inv / c_0;\n      variable k2_high: Number = 1 - k1_high / (c_max - c_mid + 0.0001);\n      variable c_diff: Number = c - k0_high;\n      variable t_high: Number = c_diff / (k1_high + k2_high * c_diff + 0.0001);\n      s = mid + 0.2 * t_high;\n    ];\n  ];\n  \n  // Clamp saturation\n  if (s > 1) [ s = 1; ];\n  if (s < 0) [ s = 0; ];\n];\n\n// ═══════════════════════════════════════════════════════════════════════════\n// Output\n// ═══════════════════════════════════════════════════════════════════════════\nvariable output: Color.OKHSL;\noutput.h = h;\noutput.s = s;\noutput.l = l;\noutput"
          }
        }
      ]
    }
  },
  {
    uri: "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/okhsv-color/0/",
    schema: {
      "name": "OKHSV",
      "type": "color",
      "description": "OKHSV color space by Björn Ottosson - a perceptually uniform HSV based on OKLab. H is hue (0-360), S is saturation (0-1), V is value (0-1). Reference: https://bottosson.github.io/posts/colorpicker/",
      "schema": {
        "type": "object",
        "properties": {
          "h": {
            "type": "number",
            "description": "Hue angle (0-360 degrees), same as OKLCH hue"
          },
          "s": {
            "type": "number",
            "description": "Saturation (0-1), ratio of chroma to maximum at this value"
          },
          "v": {
            "type": "number",
            "description": "Value/brightness (0-1), with V=1 being the brightest for that saturation"
          }
        },
        "required": [
          "h",
          "s",
          "v"
        ],
        "order": [
          "h",
          "s",
          "v"
        ],
        "additionalProperties": false
      },
      "initializers": [
        {
          "title": "OKHSV Color Initializer",
          "keyword": "okhsv",
          "description": "Creates an OKHSV color from H, S, V values",
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// OKHSV Color Initializer\n// Reference: Björn Ottosson - \"A perceptual color picker: OKHSL and OKHSV\"\n// URL: https://bottosson.github.io/posts/colorpicker/\n//\n// Creates an OKHSV color from hue, saturation, and value.\n// OKHSV is a perceptually uniform version of HSV built on OKLab.\n//\n// Parameters:\n// - h: Hue angle (0-360 degrees), same as OKLCH hue\n// - s: Saturation (0-1), ratio of chroma to maximum at this value\n// - v: Value/brightness (0-1), with V=1 being brightest for that saturation\n// - alpha: Optional alpha channel (0-1)\n//\n// Input: Object with h, s, v, and optional alpha properties\n// Output: Color.OKHSV\n\nvariable h: Number = input.h;\nvariable s: Number = input.s;\nvariable v: Number = input.v;\n\nvariable output: Color.OKHSV;\noutput.h = h;\noutput.s = s;\noutput.v = v;\n\n// Set alpha if provided\nif (input.alpha != null) [\n  output.alpha = input.alpha;\n];\n\noutput"
          }
        }
      ],
      "conversions": [
        {
          "source": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/oklab-color/0/",
          "target": "$self",
          "description": "Converts OKLab to OKHSV using Ottosson's algorithm with Halley's method refinement for gamut boundary",
          "lossless": true,
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// OKLab to OKHSV Conversion\n// Reference: Björn Ottosson - \"A perceptual color picker: OKHSL and OKHSV\"\n// URL: https://bottosson.github.io/posts/colorpicker/\n// Reference: https://github.com/color-js/color.js/blob/main/src/spaces/okhsv.js\n// Reference: https://bottosson.github.io/posts/oklab/ (original OKLab paper)\n//\n// OKHSV maps colors to a perceptually uniform HSV cylinder.\n// The algorithm finds the exact gamut boundary using compute_max_saturation\n// and positions colors relative to the cusp (maximum chroma point).\n//\n// Key difference from OKHSL:\n// - V=1 means maximum brightness (white at S=0, cusp color at S=1)\n// - More intuitive for picking saturated colors\n//\n// Input: Color.OKLab with l (0-1), a, b coordinates\n// Output: Color.OKHSV with h (0-360), s (0-1), v (0-1)\n\nvariable lab_l: Number = input.l;\nvariable lab_a: Number = input.a;\nvariable lab_b: Number = input.b;\n\n// Native constants\nvariable pi_val: Number = pi();\n\n// Toe function constants (same as OKHSL)\nvariable toe_k1: Number = 0.206;\nvariable toe_k2: Number = 0.03;\nvariable toe_k3: Number = 1.17009708737864;\n\n// ═══════════════════════════════════════════════════════════════════════════\n// Step 1: Convert to polar coordinates (L, C, H)\n// ═══════════════════════════════════════════════════════════════════════════\nvariable c: Number = sqrt(lab_a * lab_a + lab_b * lab_b);\nvariable h: Number = 0;\n\nif (c > 0.00001) [\n  // Note: ColorJS uses atan2(-b, -a) and adds 0.5, we use atan2(b, a)\n  h = atan2(lab_b, lab_a) * 180 / pi_val;\n  if (h < 0) [\n    h = h + 360;\n  ];\n];\n\n// ═══════════════════════════════════════════════════════════════════════════\n// Step 2: Initialize defaults and apply toe function to L for V\n// toe(x) = 0.5 * (k3*x - k1 + sqrt((k3*x - k1)^2 + 4*k2*k3*x))\n// ═══════════════════════════════════════════════════════════════════════════\nvariable s: Number = 0;\nvariable v: Number = lab_l;\n\n// Apply toe function to get initial V\nif (lab_l > 0.0001 && lab_l < 0.9999) [\n  variable term: Number = toe_k3 * lab_l - toe_k1;\n  v = 0.5 * (term + sqrt(term * term + 4 * toe_k2 * toe_k3 * lab_l));\n];\n\n// ═══════════════════════════════════════════════════════════════════════════\n// Step 3: Compute normalized hue direction\n// ═══════════════════════════════════════════════════════════════════════════\nvariable a_: Number = 0;\nvariable b_: Number = 0;\nif (c > 0.00001) [\n  a_ = lab_a / c;\n  b_ = lab_b / c;\n];\n\n// ═══════════════════════════════════════════════════════════════════════════\n// Pre-compute LMS coefficients (used in multiple steps)\n// ═══════════════════════════════════════════════════════════════════════════\nvariable kl: Number = 0.3963377774 * a_ + 0.2158037573 * b_;\nvariable km: Number = -0.1055613458 * a_ - 0.0638541728 * b_;\nvariable ks: Number = -0.0894841775 * a_ - 1.2914855480 * b_;\n\n// ═══════════════════════════════════════════════════════════════════════════\n// Step 4: Find maximum saturation and cusp\n// Only process if we have chroma (non-achromatic) and L is valid\n// ═══════════════════════════════════════════════════════════════════════════\nvariable s_max: Number = 0;\nvariable l_cusp: Number = 1;\nvariable c_cusp: Number = 0;\n\n// Variables for LMS intermediate calculations\nvariable l_lms: Number = 0;\nvariable m_lms: Number = 0;\nvariable s_lms: Number = 0;\n\nif (c > 0.00001 && lab_l > 0.00001 && lab_l < 0.99999) [\n  // Determine which RGB component clips first\n  variable k0: Number = 0;\n  variable k1_coef: Number = 0;\n  variable k2_coef: Number = 0;\n  variable k3_coef: Number = 0;\n  variable k4_coef: Number = 0;\n  variable wl: Number = 0;\n  variable wm: Number = 0;\n  variable ws: Number = 0;\n  \n  variable test_r: Number = -1.88170328 * a_ - 0.80936493 * b_;\n  variable test_g: Number = 1.81444104 * a_ - 1.19445276 * b_;\n  \n  if (test_r > 1) [\n    k0 = 1.19086277;\n    k1_coef = 1.76576728;\n    k2_coef = 0.59662641;\n    k3_coef = 0.75515197;\n    k4_coef = 0.56771245;\n    wl = 4.0767416621;\n    wm = -3.3077115913;\n    ws = 0.2309699292;\n  ] else [\n    if (test_g > 1) [\n      k0 = 0.73956515;\n      k1_coef = -0.45954404;\n      k2_coef = 0.08285427;\n      k3_coef = 0.12541073;\n      k4_coef = -0.14503204;\n      wl = -1.2684380046;\n      wm = 2.6097574011;\n      ws = -0.3413193965;\n    ] else [\n      k0 = 1.35733652;\n      k1_coef = -0.00915799;\n      k2_coef = -1.15130210;\n      k3_coef = -0.50559606;\n      k4_coef = 0.00692167;\n      wl = -0.0041960863;\n      wm = -0.7034186147;\n      ws = 1.7076147010;\n    ];\n  ];\n  \n  // Polynomial approximation\n  s_max = k0 + k1_coef * a_ + k2_coef * b_ + k3_coef * a_ * a_ + k4_coef * a_ * b_;\n  \n  // Halley's method refinement\n  variable l_temp: Number = 1 + s_max * kl;\n  variable m_temp: Number = 1 + s_max * km;\n  variable s_temp: Number = 1 + s_max * ks;\n  \n  variable l_cubed: Number = l_temp * l_temp * l_temp;\n  variable m_cubed: Number = m_temp * m_temp * m_temp;\n  variable s_cubed: Number = s_temp * s_temp * s_temp;\n  \n  variable l_ds: Number = 3 * kl * l_temp * l_temp;\n  variable m_ds: Number = 3 * km * m_temp * m_temp;\n  variable s_ds: Number = 3 * ks * s_temp * s_temp;\n  \n  variable l_ds2: Number = 6 * kl * kl * l_temp;\n  variable m_ds2: Number = 6 * km * km * m_temp;\n  variable s_ds2: Number = 6 * ks * ks * s_temp;\n  \n  variable f: Number = wl * l_cubed + wm * m_cubed + ws * s_cubed;\n  variable f1: Number = wl * l_ds + wm * m_ds + ws * s_ds;\n  variable f2: Number = wl * l_ds2 + wm * m_ds2 + ws * s_ds2;\n  \n  variable denom: Number = f1 * f1 - 0.5 * f * f2;\n  if (abs(denom) > 0.000001) [\n    s_max = s_max - f * f1 / denom;\n  ];\n  \n  // ═══════════════════════════════════════════════════════════════════════\n  // Find cusp (L_cusp, C_cusp)\n  // ═══════════════════════════════════════════════════════════════════════\n  if (s_max > 0) [\n    variable l_cusp_temp: Number = 1 + s_max * kl;\n    variable m_cusp_temp: Number = 1 + s_max * km;\n    variable s_cusp_temp: Number = 1 + s_max * ks;\n    \n    l_lms = l_cusp_temp * l_cusp_temp * l_cusp_temp;\n    m_lms = m_cusp_temp * m_cusp_temp * m_cusp_temp;\n    s_lms = s_cusp_temp * s_cusp_temp * s_cusp_temp;\n    \n    variable r_lin: Number = 4.0767416621 * l_lms - 3.3077115913 * m_lms + 0.2309699292 * s_lms;\n    variable g_lin: Number = -1.2684380046 * l_lms + 2.6097574011 * m_lms - 0.3413193965 * s_lms;\n    variable b_lin: Number = -0.0041960863 * l_lms - 0.7034186147 * m_lms + 1.7076147010 * s_lms;\n    \n    variable max_rgb: Number = r_lin;\n    if (g_lin > max_rgb) [ max_rgb = g_lin; ];\n    if (b_lin > max_rgb) [ max_rgb = b_lin; ];\n    \n    if (max_rgb > 0) [\n      l_cusp = pow(1 / max_rgb, 0.3333333333333333);\n      c_cusp = l_cusp * s_max;\n    ];\n  ];\n];\n\n// ═══════════════════════════════════════════════════════════════════════════\n// Step 5: Compute OKHSV S and V using ColorJS algorithm\n//\n// The algorithm uses the ST coordinate system where:\n// - S_t = C/L (slope from origin)\n// - T_t = C/(1-L) (slope from white)\n//\n// Key formulas from ColorJS:\n// - t = tMax / (c + l * tMax)\n// - lv = t * l, cv = t * c\n// - Apply RGB scaling and toe compensation\n// - v = l / lv, s = ((s0 + tMax) * cv) / (tMax * s0 + tMax * k * cv)\n// ═══════════════════════════════════════════════════════════════════════════\nif (c > 0.00001 && lab_l > 0.00001 && lab_l < 0.99999 && l_cusp > 0.0001 && c_cusp > 0.0001) [\n  // Compute ST values at cusp\n  variable s_t_cusp: Number = c_cusp / l_cusp;\n  variable t_t_cusp: Number = c_cusp / (1 - l_cusp + 0.0001);\n  \n  // Fixed s0 parameter\n  variable s_0: Number = 0.5;\n  variable k_param: Number = 1 - s_0 / s_t_cusp;\n  \n  // Compute t and derived values (following ColorJS exactly)\n  variable t: Number = t_t_cusp / (c + lab_l * t_t_cusp + 0.0001);\n  variable lv: Number = t * lab_l;\n  variable cv: Number = t * c;\n  \n  // Apply inverse toe to lv for compensation\n  variable lvt: Number = lv;\n  if (lv > 0.0001 && lv < 0.9999) [\n    lvt = (lv * lv + toe_k1 * lv) / (toe_k3 * (lv + toe_k2));\n  ];\n  \n  variable cvt: Number = cv;\n  if (lv > 0.0001) [\n    cvt = cv * lvt / lv;\n  ];\n  \n  // RGB scale computation\n  variable scale_l_: Number = 1 + s_max * kl;\n  variable scale_m_: Number = 1 + s_max * km;\n  variable scale_s_: Number = 1 + s_max * ks;\n  \n  variable lms_l: Number = lvt + a_ * cvt * kl;\n  variable lms_m: Number = lvt + a_ * cvt * km;\n  variable lms_s: Number = lvt + a_ * cvt * ks;\n  \n  // Convert to linear RGB using LMS\n  variable lms_l_cubed: Number = lms_l * lms_l * lms_l;\n  variable lms_m_cubed: Number = lms_m * lms_m * lms_m;\n  variable lms_s_cubed: Number = lms_s * lms_s * lms_s;\n  \n  variable rs: Number = 4.0767416621 * lms_l_cubed - 3.3077115913 * lms_m_cubed + 0.2309699292 * lms_s_cubed;\n  variable gs: Number = -1.2684380046 * lms_l_cubed + 2.6097574011 * lms_m_cubed - 0.3413193965 * lms_s_cubed;\n  variable bs: Number = -0.0041960863 * lms_l_cubed - 0.7034186147 * lms_m_cubed + 1.7076147010 * lms_s_cubed;\n  \n  variable max_s: Number = rs;\n  if (gs > max_s) [ max_s = gs; ];\n  if (bs > max_s) [ max_s = bs; ];\n  if (max_s < 0.0001) [ max_s = 0.0001; ];\n  \n  variable scale_l: Number = pow(1 / max_s, 0.3333333333333333);\n  \n  // Scale L and C\n  variable l_scaled: Number = lab_l / scale_l;\n  variable c_scaled: Number = c / scale_l;\n  \n  // Apply toe to scaled L for compensation\n  variable l_toed: Number = l_scaled;\n  if (l_scaled > 0.0001 && l_scaled < 0.9999) [\n    variable term2: Number = toe_k3 * l_scaled - toe_k1;\n    l_toed = 0.5 * (term2 + sqrt(term2 * term2 + 4 * toe_k2 * toe_k3 * l_scaled));\n  ];\n  \n  c_scaled = c_scaled * l_toed / (l_scaled + 0.0001);\n  \n  // Compute final v and s\n  if (lv > 0.0001) [\n    v = l_toed / lv;\n    if (v > 1) [ v = 1; ];\n    if (v < 0) [ v = 0; ];\n  ];\n  \n  variable denom_s: Number = t_t_cusp * s_0 + t_t_cusp * k_param * cv;\n  if (abs(denom_s) > 0.0001) [\n    s = ((s_0 + t_t_cusp) * cv) / denom_s;\n    if (s > 1) [ s = 1; ];\n    if (s < 0) [ s = 0; ];\n  ];\n];\n\n// ═══════════════════════════════════════════════════════════════════════════\n// Output\n// ═══════════════════════════════════════════════════════════════════════════\nvariable output: Color.OKHSV;\noutput.h = h;\noutput.s = s;\noutput.v = v;\noutput"
          }
        }
      ]
    }
  },
  {
    uri: "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/css-color/0/",
    schema: {
      "name": "CSS",
      "type": "color",
      "description": "CSS color string representation. Outputs the appropriate CSS syntax for any color space.",
      "schema": {
        "type": "object",
        "properties": {
          "value": {
            "type": "string",
            "description": "CSS color string (e.g., 'rgb(255 128 64)', 'oklch(0.7 0.15 180)')"
          }
        },
        "required": [
          "value"
        ]
      },
      "initializers": [
        {
          "title": "CSS Color Initializer",
          "keyword": "css",
          "description": "Creates a CSS color from a string value",
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// CSS Color Initializer\n// Accepts a CSS color string and returns it\n// This is primarily used for type registration; \n// the main usage is converting TO css from other color types\n//\n// Input: String (CSS color value)\n// Output: String (same value)\n\nvariable input: List = {input};\nvariable value: String = input.get(0);\n\nreturn value;"
          }
        }
      ],
      "conversions": [
        {
          "source": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/rgb-color/0/",
          "target": "$self",
          "description": "Converts RGB (0-255) to CSS rgb() syntax",
          "lossless": true,
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// RGB to CSS Conversion\n// Converts RGB (0-255) to CSS rgb() syntax\n// CSS Color Level 4 modern syntax: rgb(r g b) or rgb(r g b / alpha)\n//\n// Input: Color.Rgb with r, g, b in 0-255 range, optional alpha (0-1)\n// Output: Color.CSS with value like \"rgb(255 128 64)\" or \"rgb(255 128 64 / 0.5)\"\n// Note: Alpha is omitted if null or 1.0 (fully opaque)\n\nvariable r: Number = round({input}.r);\nvariable g: Number = round({input}.g);\nvariable b: Number = round({input}.b);\n\nvariable css_value: String = \"rgb(\".concat(r.to_string()).concat(\" \").concat(g.to_string()).concat(\" \").concat(b.to_string());\n\n// Add alpha if present, not null, and not 1.0 (per CSS convention)\nvariable alpha: Number = {input}.alpha;\nif (alpha != null) [\n  if (alpha != 1) [\n    css_value = css_value.concat(\" / \").concat(alpha.to_string());\n  ];\n];\n\ncss_value = css_value.concat(\")\");\n\nvariable output: Color.CSS;\noutput.value = css_value;\nreturn output;"
          }
        },
        {
          "source": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/srgb-color/0/",
          "target": "$self",
          "description": "Converts sRGB (0-1) to CSS color(srgb) syntax",
          "lossless": true,
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// sRGB to CSS Conversion\n// Converts sRGB (0-1) to CSS color(srgb) syntax\n// CSS Color Level 4: color(srgb r g b) or color(srgb r g b / alpha)\n//\n// Input: Color.SRGB with r, g, b in 0-1 range, optional alpha (0-1)\n// Output: Color.CSS with value like \"color(srgb 1 0.5 0.25)\" or \"color(srgb 1 0.5 0.25 / 0.5)\"\n// Note: Alpha is omitted if null or 1.0 (fully opaque)\n\nvariable precision: Number = 100000;\nvariable r: Number = round({input}.r * precision) / precision;\nvariable g: Number = round({input}.g * precision) / precision;\nvariable b: Number = round({input}.b * precision) / precision;\n\nvariable css_value: String = \"color(srgb \".concat(r.to_string()).concat(\" \").concat(g.to_string()).concat(\" \").concat(b.to_string());\n\n// Add alpha if present, not null, and not 1.0 (per CSS convention)\nvariable alpha: Number = {input}.alpha;\nif (alpha != null) [\n  if (alpha != 1) [\n    css_value = css_value.concat(\" / \").concat(alpha.to_string());\n  ];\n];\n\ncss_value = css_value.concat(\")\");\n\nvariable output: Color.CSS;\noutput.value = css_value;\nreturn output;"
          }
        },
        {
          "source": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/hsl-color/0/",
          "target": "$self",
          "description": "Converts HSL to CSS hsl() syntax",
          "lossless": true,
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// HSL to CSS Conversion\n// Converts HSL to CSS hsl() syntax\n// CSS Color Level 4: hsl(h s l) or hsl(h s l / alpha) where s and l are percentages\n//\n// Input: Color.HSL with h (0-360), s (0-1), l (0-1), optional alpha (0-1)\n// Output: Color.CSS with value like \"hsl(120 50% 75%)\" or \"hsl(120 50% 75% / 0.5)\"\n// Note: Alpha is omitted if null or 1.0 (fully opaque)\n\nvariable precision: Number = 100;\nvariable h: Number = round({input}.h * precision) / precision;\nvariable s: Number = round({input}.s * 100 * precision) / precision;\nvariable l: Number = round({input}.l * 100 * precision) / precision;\n\nvariable css_value: String = \"hsl(\".concat(h.to_string()).concat(\" \").concat(s.to_string()).concat(\"% \").concat(l.to_string()).concat(\"%\");\n\n// Add alpha if present, not null, and not 1.0 (per CSS convention)\nvariable alpha: Number = {input}.alpha;\nif (alpha != null) [\n  if (alpha != 1) [\n    css_value = css_value.concat(\" / \").concat(alpha.to_string());\n  ];\n];\n\ncss_value = css_value.concat(\")\");\n\nvariable output: Color.CSS;\noutput.value = css_value;\nreturn output;"
          }
        },
        {
          "source": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/hwb-color/0/",
          "target": "$self",
          "description": "Converts HWB to CSS hwb() syntax",
          "lossless": true,
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// HWB to CSS Conversion\n// Converts HWB to CSS hwb() syntax\n// CSS Color Level 4: hwb(h w b) or hwb(h w b / alpha) where w and b are percentages\n//\n// Input: Color.HWB with h (0-360), w (0-1), b (0-1), optional alpha (0-1)\n// Output: Color.CSS with value like \"hwb(120 10% 20%)\" or \"hwb(120 10% 20% / 0.5)\"\n// Note: Alpha is omitted if null or 1.0 (fully opaque)\n\nvariable precision: Number = 100;\nvariable h: Number = round({input}.h * precision) / precision;\nvariable w: Number = round({input}.w * 100 * precision) / precision;\nvariable b_val: Number = round({input}.b * 100 * precision) / precision;\n\nvariable css_value: String = \"hwb(\".concat(h.to_string()).concat(\" \").concat(w.to_string()).concat(\"% \").concat(b_val.to_string()).concat(\"%\");\n\n// Add alpha if present, not null, and not 1.0 (per CSS convention)\nvariable alpha: Number = {input}.alpha;\nif (alpha != null) [\n  if (alpha != 1) [\n    css_value = css_value.concat(\" / \").concat(alpha.to_string());\n  ];\n];\n\ncss_value = css_value.concat(\")\");\n\nvariable output: Color.CSS;\noutput.value = css_value;\nreturn output;"
          }
        },
        {
          "source": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/lab-color/0/",
          "target": "$self",
          "description": "Converts CIE Lab to CSS lab() syntax",
          "lossless": true,
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// CIE Lab to CSS Conversion\n// Converts CIE Lab to CSS lab() syntax\n// CSS Color Level 4: lab(L a b) or lab(L a b / alpha) where L is a percentage\n//\n// Input: Color.Lab with l (0-100), a, b, optional alpha (0-1)\n// Output: Color.CSS with value like \"lab(75% 20 -30)\" or \"lab(75% 20 -30 / 0.5)\"\n// Note: Alpha is omitted if null or 1.0 (fully opaque)\n\nvariable precision: Number = 10000;\nvariable l: Number = round({input}.l * precision) / precision;\nvariable a: Number = round({input}.a * precision) / precision;\nvariable b_val: Number = round({input}.b * precision) / precision;\n\nvariable css_value: String = \"lab(\".concat(l.to_string()).concat(\"% \").concat(a.to_string()).concat(\" \").concat(b_val.to_string());\n\n// Add alpha if present, not null, and not 1.0 (per CSS convention)\nvariable alpha: Number = {input}.alpha;\nif (alpha != null) [\n  if (alpha != 1) [\n    css_value = css_value.concat(\" / \").concat(alpha.to_string());\n  ];\n];\n\ncss_value = css_value.concat(\")\");\n\nvariable output: Color.CSS;\noutput.value = css_value;\nreturn output;"
          }
        },
        {
          "source": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/lch-color/0/",
          "target": "$self",
          "description": "Converts CIE LCH to CSS lch() syntax",
          "lossless": true,
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// CIE LCH to CSS Conversion\n// Converts CIE LCH to CSS lch() syntax\n// CSS Color Level 4: lch(L C H) or lch(L C H / alpha) where L is a percentage\n//\n// Input: Color.LCH with l (0-100), c, h (0-360), optional alpha (0-1)\n// Output: Color.CSS with value like \"lch(75% 50 180)\" or \"lch(75% 50 180 / 0.5)\"\n// Note: Alpha is omitted if null or 1.0 (fully opaque)\n\nvariable precision: Number = 10000;\nvariable l: Number = round({input}.l * precision) / precision;\nvariable c: Number = round({input}.c * precision) / precision;\nvariable h: Number = round({input}.h * precision) / precision;\n\nvariable css_value: String = \"lch(\".concat(l.to_string()).concat(\"% \").concat(c.to_string()).concat(\" \").concat(h.to_string());\n\n// Add alpha if present, not null, and not 1.0 (per CSS convention)\nvariable alpha: Number = {input}.alpha;\nif (alpha != null) [\n  if (alpha != 1) [\n    css_value = css_value.concat(\" / \").concat(alpha.to_string());\n  ];\n];\n\ncss_value = css_value.concat(\")\");\n\nvariable output: Color.CSS;\noutput.value = css_value;\nreturn output;"
          }
        },
        {
          "source": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/oklab-color/0/",
          "target": "$self",
          "description": "Converts OKLab to CSS oklab() syntax",
          "lossless": true,
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// OKLab to CSS Conversion\n// Converts OKLab to CSS oklab() syntax\n// CSS Color Level 4: oklab(L a b) or oklab(L a b / alpha) where L is 0-1 decimal\n//\n// Input: Color.OKLab with l (0-1), a, b, optional alpha (0-1)\n// Output: Color.CSS with value like \"oklab(0.7 0.1 -0.05)\" or \"oklab(0.7 0.1 -0.05 / 0.5)\"\n// Note: Alpha is omitted if null or 1.0 (fully opaque)\n\nvariable precision: Number = 100000;\nvariable l: Number = round({input}.l * precision) / precision;\nvariable a: Number = round({input}.a * precision) / precision;\nvariable b_val: Number = round({input}.b * precision) / precision;\n\nvariable css_value: String = \"oklab(\".concat(l.to_string()).concat(\" \").concat(a.to_string()).concat(\" \").concat(b_val.to_string());\n\n// Add alpha if present, not null, and not 1.0 (per CSS convention)\nvariable alpha: Number = {input}.alpha;\nif (alpha != null) [\n  if (alpha != 1) [\n    css_value = css_value.concat(\" / \").concat(alpha.to_string());\n  ];\n];\n\ncss_value = css_value.concat(\")\");\n\nvariable output: Color.CSS;\noutput.value = css_value;\nreturn output;"
          }
        },
        {
          "source": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/oklch-color/0/",
          "target": "$self",
          "description": "Converts OKLCH to CSS oklch() syntax",
          "lossless": true,
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// OKLCH to CSS Conversion\n// Converts OKLCH to CSS oklch() syntax\n// CSS Color Level 4: oklch(L C H) or oklch(L C H / alpha) where L is 0-1 decimal\n//\n// Input: Color.OKLCH with l (0-1), c, h (0-360), optional alpha (0-1)\n// Output: Color.CSS with value like \"oklch(0.7 0.15 180)\" or \"oklch(0.7 0.15 180 / 0.5)\"\n// Note: Alpha is omitted if null or 1.0 (fully opaque)\n\nvariable precision: Number = 100000;\nvariable l: Number = round({input}.l * precision) / precision;\nvariable c: Number = round({input}.c * precision) / precision;\nvariable h: Number = round({input}.h * precision) / precision;\n\nvariable css_value: String = \"oklch(\".concat(l.to_string()).concat(\" \").concat(c.to_string()).concat(\" \").concat(h.to_string());\n\n// Add alpha if present, not null, and not 1.0 (per CSS convention)\nvariable alpha: Number = {input}.alpha;\nif (alpha != null) [\n  if (alpha != 1) [\n    css_value = css_value.concat(\" / \").concat(alpha.to_string());\n  ];\n];\n\ncss_value = css_value.concat(\")\");\n\nvariable output: Color.CSS;\noutput.value = css_value;\nreturn output;"
          }
        },
        {
          "source": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/srgb-linear-color/0/",
          "target": "$self",
          "description": "Converts Linear sRGB to CSS color(srgb-linear) syntax",
          "lossless": true,
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// Linear sRGB to CSS Conversion\n// Converts Linear sRGB to CSS color(srgb-linear) syntax\n// CSS Color Level 4: color(srgb-linear r g b)\n//\n// Input: Color.LinearSRGB with r, g, b in 0-1 range\n// Output: Color.CSS with value like \"color(srgb-linear 1 0.25 0.0625)\"\n\nvariable precision: Number = 100000;\nvariable r: Number = round({input}.r * precision) / precision;\nvariable g: Number = round({input}.g * precision) / precision;\nvariable b: Number = round({input}.b * precision) / precision;\n\nvariable output: Color.CSS;\noutput.value = \"color(srgb-linear \".concat(r.to_string()).concat(\" \").concat(g.to_string()).concat(\" \").concat(b.to_string()).concat(\")\");\nreturn output;"
          }
        },
        {
          "source": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/xyz-d65-color/0/",
          "target": "$self",
          "description": "Converts XYZ-D65 to CSS color(xyz-d65) syntax",
          "lossless": true,
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// XYZ-D65 to CSS Conversion\n// Converts XYZ-D65 to CSS color(xyz-d65) syntax\n// CSS Color Level 4: color(xyz-d65 x y z) or color(xyz-d65 x y z / alpha)\n//\n// Input: Color.XYZD65 with x, y, z tristimulus values, optional alpha (0-1)\n// Output: Color.CSS with value like \"color(xyz-d65 0.4124 0.2126 0.0193)\" or \"color(xyz-d65 0.4124 0.2126 0.0193 / 0.5)\"\n// Note: Alpha is omitted if null or 1.0 (fully opaque)\n\nvariable precision: Number = 100000;\nvariable x: Number = round({input}.x * precision) / precision;\nvariable y: Number = round({input}.y * precision) / precision;\nvariable z: Number = round({input}.z * precision) / precision;\n\nvariable css_value: String = \"color(xyz-d65 \".concat(x.to_string()).concat(\" \").concat(y.to_string()).concat(\" \").concat(z.to_string());\n\n// Add alpha if present, not null, and not 1.0 (per CSS convention)\nvariable alpha: Number = {input}.alpha;\nif (alpha != null) [\n  if (alpha != 1) [\n    css_value = css_value.concat(\" / \").concat(alpha.to_string());\n  ];\n];\n\ncss_value = css_value.concat(\")\");\n\nvariable output: Color.CSS;\noutput.value = css_value;\nreturn output;"
          }
        },
        {
          "source": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/xyz-d50-color/0/",
          "target": "$self",
          "description": "Converts XYZ-D50 to CSS color(xyz-d50) syntax",
          "lossless": true,
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// XYZ-D50 to CSS Conversion\n// Converts XYZ-D50 to CSS color(xyz-d50) syntax\n// CSS Color Level 4: color(xyz-d50 x y z) or color(xyz-d50 x y z / alpha)\n//\n// Input: Color.XYZD50 with x, y, z tristimulus values, optional alpha (0-1)\n// Output: Color.CSS with value like \"color(xyz-d50 0.4360 0.2225 0.0139)\" or \"color(xyz-d50 0.4360 0.2225 0.0139 / 0.5)\"\n// Note: Alpha is omitted if null or 1.0 (fully opaque)\n\nvariable precision: Number = 100000;\nvariable x: Number = round({input}.x * precision) / precision;\nvariable y: Number = round({input}.y * precision) / precision;\nvariable z: Number = round({input}.z * precision) / precision;\n\nvariable css_value: String = \"color(xyz-d50 \".concat(x.to_string()).concat(\" \").concat(y.to_string()).concat(\" \").concat(z.to_string());\n\n// Add alpha if present, not null, and not 1.0 (per CSS convention)\nvariable alpha: Number = {input}.alpha;\nif (alpha != null) [\n  if (alpha != 1) [\n    css_value = css_value.concat(\" / \").concat(alpha.to_string());\n  ];\n];\n\ncss_value = css_value.concat(\")\");\n\nvariable output: Color.CSS;\noutput.value = css_value;\nreturn output;"
          }
        },
        {
          "source": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/p3-color/0/",
          "target": "$self",
          "description": "Converts Display-P3 to CSS color(display-p3) syntax",
          "lossless": true,
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// Display-P3 to CSS Conversion\n// Converts Display-P3 to CSS color(display-p3) syntax\n// CSS Color Level 4: color(display-p3 r g b) or color(display-p3 r g b / alpha)\n//\n// Input: Color.P3 with r, g, b in 0-1 range, optional alpha (0-1)\n// Output: Color.CSS with value like \"color(display-p3 1 0.5 0.25)\" or \"color(display-p3 1 0.5 0.25 / 0.5)\"\n// Note: Alpha is omitted if null or 1.0 (fully opaque)\n\nvariable precision: Number = 100000;\nvariable r: Number = round({input}.r * precision) / precision;\nvariable g: Number = round({input}.g * precision) / precision;\nvariable b: Number = round({input}.b * precision) / precision;\n\nvariable css_value: String = \"color(display-p3 \".concat(r.to_string()).concat(\" \").concat(g.to_string()).concat(\" \").concat(b.to_string());\n\n// Add alpha if present, not null, and not 1.0 (per CSS convention)\nvariable alpha: Number = {input}.alpha;\nif (alpha != null) [\n  if (alpha != 1) [\n    css_value = css_value.concat(\" / \").concat(alpha.to_string());\n  ];\n];\n\ncss_value = css_value.concat(\")\");\n\nvariable output: Color.CSS;\noutput.value = css_value;\nreturn output;"
          }
        }
      ]
    }
  },
  {
    uri: "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/hwb-color/0/",
    schema: {
      "name": "HWB",
      "type": "color",
      "description": "HWB color space - Hue, Whiteness, Blackness. CSS Color Level 4.",
      "schema": {
        "type": "object",
        "properties": {
          "h": {
            "type": "number",
            "description": "Hue angle (0-360 degrees)"
          },
          "w": {
            "type": "number",
            "description": "Whiteness (0-1)"
          },
          "b": {
            "type": "number",
            "description": "Blackness (0-1)"
          }
        },
        "required": [
          "h",
          "w",
          "b"
        ],
        "order": [
          "h",
          "w",
          "b"
        ],
        "additionalProperties": false
      },
      "initializers": [
        {
          "title": "HWB Color Initializer",
          "keyword": "hwb",
          "description": "Creates an HWB color from H, W, B values",
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// HWB Color Initializer\n// Creates an HWB color from H, W, B values\n// Input: List of [h, w, b] or [h, w, b, alpha] values\n\nvariable hwb_values: List = {input};\nvariable output: Color.HWB;\n\noutput.h = hwb_values.get(0);\noutput.w = hwb_values.get(1);\noutput.b = hwb_values.get(2);\n\n// Set alpha if provided as 4th parameter\nif (hwb_values.length() > 3) [\n  output.alpha = hwb_values.get(3);\n];\n\nreturn output;"
          }
        },
        {
          "title": "HWBA Color Initializer",
          "keyword": "hwba",
          "description": "Creates an HWB color with alpha from H, W, B, A values",
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// HWBA Color Initializer\n// Creates an HWB color with alpha from H, W, B, A values\n//\n// Usage: hwba(180, 0.2, 0.3, 0.9) → Color.HWB { h: 180, w: 0.2, b: 0.3, alpha: 0.9 }\n//\n// Input: List of 4 numbers [h, w, b, alpha]\n// Output: Color.HWB with alpha\n\nvariable hwb_values: List = {input};\nvariable output: Color.HWB;\n\noutput.h = hwb_values.get(0);\noutput.w = hwb_values.get(1);\noutput.b = hwb_values.get(2);\noutput.alpha = hwb_values.get(3);\n\nreturn output;"
          }
        }
      ],
      "conversions": [
        {
          "source": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/hsv-color/0/",
          "target": "$self",
          "description": "Converts HSV to HWB",
          "lossless": true,
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// HSV to HWB Conversion\n// Reference: CSS Color Level 4\n//\n// Algorithm:\n// H stays the same\n// W = (1 - S) * V  (Whiteness)\n// B = 1 - V        (Blackness)\n//\n// Input: Color.HSV with h, s, v values\n// Output: Color.HWB with h, w, b values\n\n// Get input HSV values\nvariable h: Number = {input}.h;\nvariable s: Number = {input}.s;\nvariable v: Number = {input}.v;\n\n// Calculate whiteness and blackness\nvariable w: Number = (1 - s) * v;\nvariable b: Number = 1 - v;\n\n// Create output\nvariable output: Color.HWB;\noutput.h = h;\noutput.w = w;\noutput.b = b;\n\nreturn output;"
          }
        }
      ]
    }
  },
  {
    uri: "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/hsv-color/0/",
    schema: {
      "name": "HSV",
      "type": "color",
      "description": "HSV color space - Hue, Saturation, Value. Also known as HSB (Hue, Saturation, Brightness).",
      "schema": {
        "type": "object",
        "properties": {
          "h": {
            "type": "number",
            "description": "Hue angle (0-360 degrees)"
          },
          "s": {
            "type": "number",
            "description": "Saturation (0-1)"
          },
          "v": {
            "type": "number",
            "description": "Value/Brightness (0-1)"
          }
        },
        "required": [
          "h",
          "s",
          "v"
        ],
        "order": [
          "h",
          "s",
          "v"
        ],
        "additionalProperties": false
      },
      "initializers": [
        {
          "title": "HSV Color Initializer",
          "keyword": "hsv",
          "description": "Creates an HSV color from H, S, V values",
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// HSV Color Initializer\n// Creates an HSV color from H, S, V values\n// Input: List of [h, s, v] or [h, s, v, alpha] values\n\nvariable hsv_values: List = {input};\nvariable output: Color.HSV;\n\noutput.h = hsv_values.get(0);\noutput.s = hsv_values.get(1);\noutput.v = hsv_values.get(2);\n\n// Set alpha if provided as 4th parameter\nif (hsv_values.length() > 3) [\n  output.alpha = hsv_values.get(3);\n];\n\nreturn output;"
          }
        }
      ],
      "conversions": [
        {
          "source": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/srgb-color/0/",
          "target": "$self",
          "description": "Converts sRGB to HSV",
          "lossless": true,
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// sRGB to HSV Conversion\n// Reference: Standard RGB to HSV algorithm\n//\n// Algorithm:\n// V = max(R, G, B)\n// S = (V - min(R, G, B)) / V  (if V > 0)\n// H depends on which channel is max\n//\n// Input: Color.SRGB with r, g, b in 0-1 range\n// Output: Color.HSV with h (0-360), s (0-1), v (0-1)\n\n// Get input sRGB values\nvariable r: Number = {input}.r;\nvariable g: Number = {input}.g;\nvariable b: Number = {input}.b;\n\n// Find max and min\nvariable max_val: Number = r;\nif (g > max_val) [\n    max_val = g;\n];\nif (b > max_val) [\n    max_val = b;\n];\n\nvariable min_val: Number = r;\nif (g < min_val) [\n    min_val = g;\n];\nif (b < min_val) [\n    min_val = b;\n];\n\n// Value is the max channel\nvariable v: Number = max_val;\n\n// Calculate saturation and hue\nvariable s: Number = 0;\nvariable h: Number = 0;\nvariable delta: Number = max_val - min_val;\n\nif (max_val > 0) [\n    s = delta / max_val;\n];\n\nif (delta > 0) [\n    // Hue calculation depends on which channel is max\n    if (max_val == r) [\n        h = ((g - b) / delta);\n        if (g < b) [\n            h = h + 6;\n        ];\n    ] else [\n        if (max_val == g) [\n            h = (b - r) / delta + 2;\n        ] else [\n            h = (r - g) / delta + 4;\n        ];\n    ];\n    \n    // Convert to degrees\n    h = h * 60;\n];\n\n// Normalize hue to 0-360\nif (h < 0) [\n    h = h + 360;\n];\n\n// Create output\nvariable output: Color.HSV;\noutput.h = h;\noutput.s = s;\noutput.v = v;\n\nreturn output;"
          }
        }
      ]
    }
  },
  {
    uri: "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/lab-color/0/",
    schema: {
      "name": "Lab",
      "type": "color",
      "description": "CIE Lab (L*a*b*) perceptually uniform color space. L is lightness (0-100), a is green-red axis, b is blue-yellow axis.",
      "schema": {
        "type": "object",
        "properties": {
          "l": {
            "type": "number",
            "description": "Lightness (0-100)"
          },
          "a": {
            "type": "number",
            "description": "Green-red axis (typically -125 to 125)"
          },
          "b": {
            "type": "number",
            "description": "Blue-yellow axis (typically -125 to 125)"
          }
        },
        "required": [
          "l",
          "a",
          "b"
        ],
        "order": [
          "l",
          "a",
          "b"
        ],
        "additionalProperties": false
      },
      "initializers": [
        {
          "title": "Lab Color Initializer",
          "keyword": "lab",
          "description": "Creates a CIE Lab color from L, a, b values",
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// CIE Lab Color Initializer\n// Creates a Lab color from L, a, b values\n// Input: List of [l, a, b] or [l, a, b, alpha] values\n\nvariable lab_values: List = {input};\nvariable output: Color.Lab;\n\noutput.l = lab_values.get(0);\noutput.a = lab_values.get(1);\noutput.b = lab_values.get(2);\n\n// Set alpha if provided as 4th parameter\nif (lab_values.length() > 3) [\n  output.alpha = lab_values.get(3);\n];\n\nreturn output;"
          }
        }
      ],
      "conversions": [
        {
          "source": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/xyz-d50-color/0/",
          "target": "$self",
          "description": "Converts XYZ-D50 to CIE Lab using the CIE standard formula",
          "lossless": true,
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// XYZ-D50 to CIE Lab Conversion\n// Reference: CIE 15.3:2004 section 8.2.1.1\n// Reference: https://github.com/color-js/color.js/blob/main/src/spaces/lab.js\n//\n// Algorithm:\n// 1. Scale XYZ by D50 white point reference\n// 2. Apply f function: f(x) = x > ε ? cbrt(x) : (κ*x + 16)/116\n// 3. L = 116 * f[Y] - 16\n// 4. a = 500 * (f[X] - f[Y])\n// 5. b = 200 * (f[Y] - f[Z])\n//\n// Input: Color.XYZD50 with x, y, z tristimulus\n// Output: Color.Lab with l, a, b coordinates\n\n// Get input XYZ-D50 values\nvariable x: Number = {input}.x;\nvariable y: Number = {input}.y;\nvariable z: Number = {input}.z;\n\n// CIE constants (exact rational fractions)\n// ε = 216/24389 = (6/29)^3\nvariable epsilon: Number = 0.008856451679035631;\n// κ = 24389/27 = (29/3)^3  \nvariable kappa: Number = 903.2962962962963;\n\n// D50 white point reference (ColorJS exact values)\n// D50: [0.3457/0.3585, 1.0, (1-0.3457-0.3585)/0.3585]\nvariable white_x: Number = 0.9642956764295677;\nvariable white_y: Number = 1.0;\nvariable white_z: Number = 0.8251046025104602;\n\n// Scale XYZ by white point\nvariable xr: Number = x / white_x;\nvariable yr: Number = y / white_y;\nvariable zr: Number = z / white_z;\n\n// Apply f function with cube root\n// f(t) = t > ε ? t^(1/3) : (κt + 16) / 116\nvariable cube_root_exp: Number = 0.3333333333333333;\n\nvariable fx: Number = 0;\nvariable fy: Number = 0;\nvariable fz: Number = 0;\n\nif (xr > epsilon) [\n    fx = pow(xr, cube_root_exp);\n] else [\n    fx = (kappa * xr + 16) / 116;\n];\n\nif (yr > epsilon) [\n    fy = pow(yr, cube_root_exp);\n] else [\n    fy = (kappa * yr + 16) / 116;\n];\n\nif (zr > epsilon) [\n    fz = pow(zr, cube_root_exp);\n] else [\n    fz = (kappa * zr + 16) / 116;\n];\n\n// Calculate Lab values\nvariable lab_l: Number = 116 * fy - 16;\nvariable lab_a: Number = 500 * (fx - fy);\nvariable lab_b: Number = 200 * (fy - fz);\n\n// Create output\nvariable output: Color.Lab;\noutput.l = lab_l;\noutput.a = lab_a;\noutput.b = lab_b;\n\nreturn output;"
          }
        }
      ]
    }
  },
  {
    uri: "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/xyz-d50-color/0/",
    schema: {
      "name": "XYZD50",
      "type": "color",
      "description": "CIE XYZ color space with D50 white point. Used for Lab and LCH color spaces.",
      "schema": {
        "type": "object",
        "properties": {
          "x": {
            "type": "number",
            "description": "X tristimulus value"
          },
          "y": {
            "type": "number",
            "description": "Y tristimulus value (luminance)"
          },
          "z": {
            "type": "number",
            "description": "Z tristimulus value"
          }
        },
        "required": [
          "x",
          "y",
          "z"
        ],
        "order": [
          "x",
          "y",
          "z"
        ],
        "additionalProperties": false
      },
      "initializers": [
        {
          "title": "XYZ-D50 Color Initializer",
          "keyword": "xyzd50",
          "description": "Creates an XYZ-D50 color from tristimulus values",
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// XYZ-D50 Color Initializer\n// Creates an XYZ-D50 color from tristimulus values\n// Input: List of [x, y, z] tristimulus values\n\nvariable xyz_values: List = {input};\nvariable output: Color.XYZD50;\n\noutput.x = xyz_values.get(0);\noutput.y = xyz_values.get(1);\noutput.z = xyz_values.get(2);\n\nreturn output;"
          }
        }
      ],
      "conversions": [
        {
          "source": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/xyz-d65-color/0/",
          "target": "$self",
          "description": "Converts XYZ-D65 to XYZ-D50 using Bradford chromatic adaptation",
          "lossless": true,
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// XYZ-D65 to XYZ-D50 Conversion\n// Chromatic adaptation using Bradford transform\n// Reference: https://github.com/color-js/color.js/blob/main/src/adapt.js\n//\n// Bradford CAT matrix for D65 → D50:\n// [1.0479298   0.0229469  -0.0501923]\n// [0.0296278   0.9904344  -0.0170738]\n// [-0.0092430  0.0150552   0.7518743]\n//\n// Input: Color.XYZD65 with x, y, z tristimulus (D65 white)\n// Output: Color.XYZD50 with x, y, z tristimulus (D50 white)\n\n// Get input XYZ-D65 values\nvariable x65: Number = {input}.x;\nvariable y65: Number = {input}.y;\nvariable z65: Number = {input}.z;\n\n// Bradford chromatic adaptation matrix (ColorJS exact values)\n// Row 1\nvariable x50: Number = x65 * 1.0479297925449969 + y65 * 0.022946870601609652 + z65 * -0.05019226628920524;\n// Row 2\nvariable y50: Number = x65 * 0.02962780877005599 + y65 * 0.9904344267538799 + z65 * -0.017073799063418826;\n// Row 3\nvariable z50: Number = x65 * -0.009243040646204504 + y65 * 0.015055191490298152 + z65 * 0.7518742814281371;\n\n// Create output\nvariable output: Color.XYZD50;\noutput.x = x50;\noutput.y = y50;\noutput.z = z50;\n\nreturn output;"
          }
        }
      ]
    }
  },
  {
    uri: "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/lch-color/0/",
    schema: {
      "name": "LCH",
      "type": "color",
      "description": "CIE LCH color space - the polar form of CIE Lab. L is lightness (0-100), C is chroma, H is hue angle (0-360).",
      "schema": {
        "type": "object",
        "properties": {
          "l": {
            "type": "number",
            "description": "Lightness (0-100)"
          },
          "c": {
            "type": "number",
            "description": "Chroma"
          },
          "h": {
            "type": "number",
            "description": "Hue angle (0-360 degrees)"
          }
        },
        "required": [
          "l",
          "c",
          "h"
        ],
        "order": [
          "l",
          "c",
          "h"
        ],
        "additionalProperties": false
      },
      "initializers": [
        {
          "title": "LCH Color Initializer",
          "keyword": "lch",
          "description": "Creates a CIE LCH color from L, C, H values",
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// CIE LCH Color Initializer\n// Creates a LCH color from L, C, H values\n// Input: List of [l, c, h] or [l, c, h, alpha] values\n\nvariable lch_values: List = {input};\nvariable output: Color.LCH;\n\noutput.l = lch_values.get(0);\noutput.c = lch_values.get(1);\noutput.h = lch_values.get(2);\n\n// Set alpha if provided as 4th parameter\nif (lch_values.length() > 3) [\n  output.alpha = lch_values.get(3);\n];\n\nreturn output;"
          }
        }
      ],
      "conversions": [
        {
          "source": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/lab-color/0/",
          "target": "$self",
          "description": "Converts CIE Lab to LCH using Cartesian to polar transformation",
          "lossless": true,
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// CIE Lab to LCH Conversion\n// Converts Cartesian (a, b) to polar (C, H) coordinates\n// Same algorithm as OKLab → OKLCH, but for CIE Lab\n//\n// Algorithm:\n// L stays the same (lightness 0-100)\n// C = sqrt(a² + b²) (chroma)\n// H = atan2(b, a) * 180/π (hue angle in degrees)\n//\n// Input: Color.Lab with l, a, b coordinates\n// Output: Color.LCH with l, c, h coordinates\n\n// Get input Lab values\nvariable l: Number = {input}.l;\nvariable a: Number = {input}.a;\nvariable b: Number = {input}.b;\n\n// Constants\nvariable pi: Number = pi();\nvariable rad_to_deg: Number = 180 / pi;\n\n// Calculate chroma (distance from neutral axis)\nvariable c: Number = sqrt(a * a + b * b);\n\n// Calculate hue angle using atan2\nvariable h_rad: Number = atan2(b, a);\nvariable h: Number = h_rad * rad_to_deg;\n\n// Normalize hue to 0-360 range\nif (h < 0) [\n    h = h + 360;\n];\n\n// Create output\nvariable output: Color.LCH;\noutput.l = l;\noutput.c = c;\noutput.h = h;\n\nreturn output;"
          }
        }
      ]
    }
  },
  {
    uri: "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/p3-color/0/",
    schema: {
      "name": "P3",
      "type": "color",
      "description": "Display-P3 color space with sRGB transfer function. Wider gamut than sRGB, common on modern Apple displays.",
      "schema": {
        "type": "object",
        "properties": {
          "r": {
            "type": "number",
            "description": "Red channel (0-1, can exceed for out-of-gamut)"
          },
          "g": {
            "type": "number",
            "description": "Green channel (0-1, can exceed for out-of-gamut)"
          },
          "b": {
            "type": "number",
            "description": "Blue channel (0-1, can exceed for out-of-gamut)"
          }
        },
        "required": [
          "r",
          "g",
          "b"
        ],
        "order": [
          "r",
          "g",
          "b"
        ],
        "additionalProperties": false
      },
      "initializers": [
        {
          "title": "Display-P3 Color Initializer",
          "keyword": "p3",
          "description": "Creates a Display-P3 color from 0-1 values",
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// Display-P3 Color Initializer\n// Creates a Display-P3 color from 0-1 values\n// Input: List of [r, g, b] or [r, g, b, alpha] values\n\nvariable color_values: List = {input};\nvariable output: Color.P3;\n\noutput.r = color_values.get(0);\noutput.g = color_values.get(1);\noutput.b = color_values.get(2);\n\n// Set alpha if provided as 4th parameter\nif (color_values.length() > 3) [\n  output.alpha = color_values.get(3);\n];\n\nreturn output;"
          }
        }
      ],
      "conversions": [
        {
          "source": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/p3-linear-color/0/",
          "target": "$self",
          "description": "Converts Linear P3 to P3 by applying sRGB transfer function",
          "lossless": true,
          "script": {
            "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
            "script": "// Linear P3 to P3 Conversion\n// Applies sRGB transfer function (gamma encoding)\n// P3 uses the same transfer function as sRGB\n// Reference: CSS Color Level 4\n//\n// Algorithm (same as sRGB):\n//   if linear ≤ 0.0031308: encoded = 12.92 × linear\n//   else: encoded = 1.055 × linear^(1/2.4) - 0.055\n//\n// Input: Color.LinearP3 with linear r, g, b values\n// Output: Color.P3 with gamma-encoded r, g, b values\n\n// Transfer function constants (same as sRGB)\nvariable threshold: Number = 0.0031308;\nvariable linear_scale: Number = 12.92;\nvariable gamma_scale: Number = 1.055;\nvariable gamma_offset: Number = 0.055;\nvariable gamma_exponent: Number = 0.4166666666666667;\n\n// Get linear values\nvariable linear_r: Number = {input}.r;\nvariable linear_g: Number = {input}.g;\nvariable linear_b: Number = {input}.b;\n\n// Convert red channel\nvariable encoded_r: Number = 0;\nif (linear_r <= threshold) [\n    encoded_r = linear_scale * linear_r;\n] else [\n    encoded_r = gamma_scale * pow(linear_r, gamma_exponent) - gamma_offset;\n];\n\n// Convert green channel\nvariable encoded_g: Number = 0;\nif (linear_g <= threshold) [\n    encoded_g = linear_scale * linear_g;\n] else [\n    encoded_g = gamma_scale * pow(linear_g, gamma_exponent) - gamma_offset;\n];\n\n// Convert blue channel\nvariable encoded_b: Number = 0;\nif (linear_b <= threshold) [\n    encoded_b = linear_scale * linear_b;\n] else [\n    encoded_b = gamma_scale * pow(linear_b, gamma_exponent) - gamma_offset;\n];\n\n// Create output\nvariable output: Color.P3;\noutput.r = encoded_r;\noutput.g = encoded_g;\noutput.b = encoded_b;\n\nreturn output;"
          }
        }
      ]
    }
  },
  {
    uri: "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/function/lighten/0/",
    schema: {
      "name": "Lighten",
      "type": "function",
      "description": "Makes a color lighter by increasing its lightness in OKLab space. Amount is 0-1 where 0.25 = 25% lighter.",
      "keyword": "lighten",
      "input": {
        "type": "object",
        "properties": {
          "color": {
            "type": "color",
            "description": "The color to lighten"
          },
          "amount": {
            "type": "number",
            "description": "Amount to lighten (0-1). Default is 0.25"
          }
        }
      },
      "script": {
        "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
        "script": "// lighten: Increase lightness proportionally towards white\n// Amount: 0-1 where 0.25 means 25% closer to white\n//\n// Algorithm: L' = L + (1 - L) * amount\n// This ensures we approach white (L=1) proportionally.\n//\n// Input:  Any color space (converted to OKLab internally)\n// Output: OKLCH (working space)\n// To get sRGB: lighten(color, 0.25).to.srgb()\n\nvariable input: List = {input};\nvariable color: Color.OKLab = input.get(0).to.oklab();\n\n// Default amount is 0.25 (25%)\nvariable amount: Number = 0.25;\nif (input.length() > 1) [\n    amount = input.get(1);\n];\n\n// Calculate new lightness (move toward 1)\nvariable current_l: Number = color.l;\nvariable new_l: Number = current_l + (1 - current_l) * amount;\n\n// Clamp to valid range\nif (new_l > 1) [ new_l = 1; ];\n\n// Create output in OKLab, return as OKLCH (working space)\nvariable result: Color.OKLab;\nresult.l = new_l;\nresult.a = color.a;\nresult.b = color.b;\n\nreturn result.to.oklch();"
      },
      "requirements": [
        "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/oklab-color/0/",
        "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/srgb-color/0/"
      ]
    }
  },
  {
    uri: "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/function/darken/0/",
    schema: {
      "name": "Darken",
      "type": "function",
      "description": "Makes a color darker by decreasing its lightness in OKLab space. Amount is 0-1 where 0.25 = 25% darker.",
      "keyword": "darken",
      "input": {
        "type": "object",
        "properties": {
          "color": {
            "type": "color",
            "description": "The color to darken"
          },
          "amount": {
            "type": "number",
            "description": "Amount to darken (0-1). Default is 0.25"
          }
        }
      },
      "script": {
        "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
        "script": "// darken: Decrease lightness proportionally towards black\n// Amount: 0-1 where 0.25 means 25% closer to black\n//\n// Algorithm: L' = L * (1 - amount)\n// This ensures we approach black (L=0) proportionally.\n//\n// Input:  Any color space (converted to OKLab internally)\n// Output: OKLCH (working space)\n// To get sRGB: darken(color, 0.25).to.srgb()\n\nvariable input: List = {input};\nvariable color: Color.OKLab = input.get(0).to.oklab();\n\n// Default amount is 0.25 (25%)\nvariable amount: Number = 0.25;\nif (input.length() > 1) [\n    amount = input.get(1);\n];\n\n// Calculate new lightness (move toward 0)\nvariable current_l: Number = color.l;\nvariable new_l: Number = current_l * (1 - amount);\n\n// Clamp to valid range\nif (new_l < 0) [ new_l = 0; ];\n\n// Create output in OKLab, return as OKLCH (working space)\nvariable result: Color.OKLab;\nresult.l = new_l;\nresult.a = color.a;\nresult.b = color.b;\n\nreturn result.to.oklch();"
      },
      "requirements": [
        "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/oklab-color/0/",
        "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/srgb-color/0/"
      ]
    }
  },
  {
    uri: "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/function/saturate/0/",
    schema: {
      "name": "Saturate",
      "type": "function",
      "description": "Increases color saturation by boosting chroma in OKLCH space. Amount is 0-1 where 0.25 = 25% more saturated.",
      "keyword": "saturate",
      "input": {
        "type": "object",
        "properties": {
          "color": {
            "type": "color",
            "description": "The color to saturate"
          },
          "amount": {
            "type": "number",
            "description": "Amount to saturate (0-1). Default is 0.25"
          }
        }
      },
      "script": {
        "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
        "script": "// Saturate a color by increasing its OKLCH chroma\n// Amount: 0-1 where 0.25 means 25% increase\n//\n// Algorithm: C' = C * (1 + amount)\n// Chroma has no strict upper bound but ~0.4 is practical max for sRGB\n\nvariable input: List = {input};\nvariable color: Color.OKLCH = input.get(0).to.oklch();\n\n// Default amount is 0.25 (25%)\nvariable amount: Number = 0.25;\nif (input.length() > 1) [\n    amount = input.get(1);\n];\n\n// Calculate new chroma\nvariable current_c: Number = color.c;\nvariable new_c: Number = current_c * (1 + amount);\n\n// Soft clamp at 0.4 (approximate sRGB gamut max)\nif (new_c > 0.4) [ new_c = 0.4; ];\n\n// Create output in OKLCH, return as sRGB\nvariable result: Color.OKLCH;\nresult.l = color.l;\nresult.c = new_c;\nresult.h = color.h;\n\nreturn result;"
      },
      "requirements": [
        "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/oklch-color/0/",
        "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/srgb-color/0/"
      ]
    }
  },
  {
    uri: "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/function/desaturate/0/",
    schema: {
      "name": "Desaturate",
      "type": "function",
      "description": "Decreases color saturation by reducing chroma in OKLCH space. Amount is 0-1 where 0.25 = 25% less saturated.",
      "keyword": "desaturate",
      "input": {
        "type": "object",
        "properties": {
          "color": {
            "type": "color",
            "description": "The color to desaturate"
          },
          "amount": {
            "type": "number",
            "description": "Amount to desaturate (0-1). Default is 0.25"
          }
        }
      },
      "script": {
        "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
        "script": "// Desaturate a color by decreasing its OKLCH chroma\n// Amount: 0-1 where 0.25 means 25% decrease, 1.0 = full grayscale\n//\n// Algorithm: C' = C * (1 - amount)\n\nvariable input: List = {input};\nvariable color: Color.OKLCH = input.get(0).to.oklch();\n\n// Default amount is 0.25 (25%)\nvariable amount: Number = 0.25;\nif (input.length() > 1) [\n    amount = input.get(1);\n];\n\n// Calculate new chroma\nvariable current_c: Number = color.c;\nvariable new_c: Number = current_c * (1 - amount);\n\n// Clamp to valid range\nif (new_c < 0) [ new_c = 0; ];\n\n// Create output in OKLCH, return as sRGB\nvariable result: Color.OKLCH;\nresult.l = color.l;\nresult.c = new_c;\nresult.h = color.h;\n\nreturn result;"
      },
      "requirements": [
        "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/oklch-color/0/",
        "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/srgb-color/0/"
      ]
    }
  },
  {
    uri: "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/function/mix/0/",
    schema: {
      "name": "Mix",
      "type": "function",
      "description": "Blends two colors together in OKLCH space. Amount 0 = first color, 1 = second color, 0.5 = equal blend.",
      "keyword": "mix",
      "input": {
        "type": "object",
        "properties": {
          "color1": {
            "type": "color",
            "description": "First color"
          },
          "color2": {
            "type": "color",
            "description": "Second color"
          },
          "amount": {
            "type": "number",
            "description": "Blend amount (0-1). Default is 0.5"
          }
        }
      },
      "script": {
        "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
        "script": "// mix: Blend two colors in perceptual space\n// Uses shortest hue path for natural color blending.\n//\n// Algorithm: Linear interpolation on L, C, and shortest-path H\n//\n// Input:  Any color space (converted to OKLCH internally)\n// Output: OKLCH (working space)\n// To get sRGB: mix(color1, color2, 0.5).to.srgb()\n\nvariable input: List = {input};\nvariable color1: Color.OKLCH = input.get(0).to.oklch();\nvariable color2: Color.OKLCH = input.get(1).to.oklch();\n\n// Default amount is 0.5 (50/50 blend)\nvariable amount: Number = 0.5;\nif (input.length() > 2) [\n    amount = input.get(2);\n];\n\n// Interpolate lightness and chroma linearly\nvariable new_l: Number = color1.l + (color2.l - color1.l) * amount;\nvariable new_c: Number = color1.c + (color2.c - color1.c) * amount;\n\n// Interpolate hue using shortest path\nvariable h1: Number = color1.h;\nvariable h2: Number = color2.h;\nvariable h_diff: Number = h2 - h1;\n\n// Normalize to shortest path (-180 to 180)\nif (h_diff > 180) [ h_diff = h_diff - 360; ];\nif (h_diff < -180) [ h_diff = h_diff + 360; ];\n\nvariable new_h: Number = h1 + h_diff * amount;\nif (new_h < 0) [ new_h = new_h + 360; ];\nif (new_h >= 360) [ new_h = new_h - 360; ];\n\n// Create mixed color\nvariable result: Color.OKLCH;\nresult.l = new_l;\nresult.c = new_c;\nresult.h = new_h;\n\nreturn result;"
      },
      "requirements": [
        "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/oklch-color/0/",
        "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/srgb-color/0/"
      ]
    }
  },
  {
    uri: "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/function/invert/0/",
    schema: {
      "name": "Invert Color",
      "type": "function",
      "description": "Inverts a color by inverting each RGB channel (R' = 255 - R, G' = 255 - G, B' = 255 - B).",
      "keyword": "invert",
      "input": {
        "type": "object",
        "properties": {
          "color": {
            "type": "color",
            "description": "The color to invert."
          }
        }
      },
      "script": {
        "type": "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/tokenscript/0/",
        "script": "// Invert Color Function\n// Returns the inverse/negative of a color by subtracting each RGB channel from 255\n//\n// Algorithm:\n//   R' = 255 - R\n//   G' = 255 - G  \n//   B' = 255 - B\n//\n// Use cases:\n//   - Creating negative images\n//   - High contrast accessibility variants\n//   - Artistic color effects\n//\n// Input: Any color (converted to RGB internally)\n// Output: Color.Rgb with inverted channels\n\nvariable input: List = {input};\n\n// Convert input to RGB (0-255 range)\nvariable rgb_color: Color.Rgb = input.get(0).to.rgb();\n\n// Invert each channel by subtracting from 255\nvariable inverted_r: Number = 255 - rgb_color.r;\nvariable inverted_g: Number = 255 - rgb_color.g;\nvariable inverted_b: Number = 255 - rgb_color.b;\n\n// Create and return the inverted color\nvariable inverted_color: Color.Rgb = rgb(inverted_r, inverted_g, inverted_b);\nreturn inverted_color;"
      },
      "requirements": [
        "https://schema.tokenscript.dev.gcp.tokens.studio/api/v1/core/rgb-color/0/"
      ]
    }
  },
];

export function makeConfig() {
  return new Config().registerSchemas(SCHEMAS);
}
